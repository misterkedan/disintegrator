(()=>{"use strict";function t(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function e(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var n=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,n),this.callbacks="function"==typeof e?[e]:e,this.fps=i,this.elapsed=0,this._last=0,this._delta=0,this._isPlaying=!1,this._tick=this.tick.bind(this)}var i,r,o;return i=n,(r=[{key:"add",value:function(t){this.has(t)||this.callbacks.push(t)}},{key:"remove",value:function(t){this.has(t)&&this.callbacks.splice(this.callbacks.indexOf(t),1)}},{key:"has",value:function(t){return this.callbacks.includes(t)}},{key:"reset",value:function(){this.elapsed=0}},{key:"start",value:function(){this._last=this.now,this._delta=0,this._isPlaying=!0,this.requestFrame()}},{key:"pause",value:function(){this._isPlaying=!1}},{key:"stop",value:function(){this.pause(),this.reset()}},{key:"tick",value:function(){var t=this;if(this.isPlaying){this.requestFrame();var e=this.now,i=Math.min(n.maxDelta,e-this._last);this._last=e,this._delta+=i,this.elapsed+=i;var r=this._frameDuration-this._delta;r<=0&&(this.callbacks.forEach((function(e){return e.call(t,t.elapsed,t._delta)})),this._delta=Math.abs(r))}}},{key:"requestFrame",value:function(){requestAnimationFrame(this._tick)}},{key:"fps",get:function(){return this._fps},set:function(t){this._fps=t,this._frameDuration=t>0?Math.floor(1e3/t):0}},{key:"isPlaying",get:function(){return this._isPlaying}},{key:"now",get:function(){return n.time.now()}}])&&e(i.prototype,r),o&&e(i,o),n}();n.maxDelta=100,n.time=void 0===performance?Date:performance;const i=THREE;var r=new i.Scene;r.background=new i.Color(2236967),r.fog=new i.Fog(r.background,1,60);var o=new THREE.DirectionalLight(16768477,.5);o.position.set(5,5,5),r.add(o);var a=new i.HemisphereLight(16777198,3158325,1.5);r.add(a);var s,u,l,d,c={hemisphere:a},h=window.innerWidth/window.innerHeight,f=new i.PerspectiveCamera(45,h,.1,1e3);f.lookAt(0,0,0),s=f.aspect>=1?1:1.5,u=3.5*s,l=2.5*s,d=4.5*s,f.position.set(u,l,d);var p=function(){var t=3158069;if(1===window.devicePixelRatio)return new i.GridHelper(100,40,t,t);var e=new i.Mesh(new i.PlaneGeometry(100,100,40,40),new i.MeshBasicMaterial({color:t,wireframe:!0,transparent:!0,opacity:.25}));return e.rotation.x=-Math.PI/2,e}();p.position.y=-2,r.add(p);var m={scene:r,camera:f,lights:c,grid:p,add:function(t){r.add(t)},remove:function(t){r.remove(t)},resize:function(t,e){f.aspect=t/e,f.updateProjectionMatrix()}},g={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"};class v{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const x=new i.OrthographicCamera(-1,1,1,-1,0,1),y=new i.BufferGeometry;y.setAttribute("position",new i.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),y.setAttribute("uv",new i.Float32BufferAttribute([0,2,0,0,2,0],2));class A{constructor(t){this._mesh=new i.Mesh(y,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,x)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class b extends v{constructor(t,e){super(),this.textureID=void 0!==e?e:"tDiffuse",t instanceof i.ShaderMaterial?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=i.UniformsUtils.clone(t.uniforms),this.material=new i.ShaderMaterial({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new A(this.material)}render(t,e,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}}class _ extends v{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,n){const i=t.getContext(),r=t.state;let o,a;r.buffers.color.setMask(!1),r.buffers.depth.setMask(!1),r.buffers.color.setLocked(!0),r.buffers.depth.setLocked(!0),this.inverse?(o=0,a=1):(o=1,a=0),r.buffers.stencil.setTest(!0),r.buffers.stencil.setOp(i.REPLACE,i.REPLACE,i.REPLACE),r.buffers.stencil.setFunc(i.ALWAYS,o,4294967295),r.buffers.stencil.setClear(a),r.buffers.stencil.setLocked(!0),t.setRenderTarget(n),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),r.buffers.color.setLocked(!1),r.buffers.depth.setLocked(!1),r.buffers.stencil.setLocked(!1),r.buffers.stencil.setFunc(i.EQUAL,1,4294967295),r.buffers.stencil.setOp(i.KEEP,i.KEEP,i.KEEP),r.buffers.stencil.setLocked(!0)}}class N extends v{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}new i.OrthographicCamera(-1,1,1,-1,0,1);const T=new i.BufferGeometry;T.setAttribute("position",new i.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),T.setAttribute("uv",new i.Float32BufferAttribute([0,2,0,0,2,0],2));class F extends v{constructor(t,e,n,r,o){super(),this.scene=t,this.camera=e,this.overrideMaterial=n,this.clearColor=r,this.clearAlpha=void 0!==o?o:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new i.Color}render(t,e,n){const i=t.autoClear;let r,o;t.autoClear=!1,void 0!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),r=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:n),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,r),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=o),t.autoClear=i}}var S={glsl:"\n\t\nvec4 pack( float value ) {\n\n\tif ( value == 0.0 ) return vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\tfloat mag = abs( value );\n\t\n\tfloat exponent = floor( log2( mag ) );\n\texponent += float( exp2( exponent ) <= mag / 2.0 );\n\texponent -= float( exp2( exponent ) > mag );\n\n\tfloat mantissa = ( exponent > 100.0 )\n\t\t? mag / 1024.0 / exp2( exponent - 10.0 ) - 1.0\n\t\t: mag / float( exp2( exponent ) ) - 1.0;\n\n\tfloat r = exponent + 127.0;\n\tmantissa *= 256.0;\n\n\tfloat g = floor( mantissa );\n\tmantissa -= g;\n\tmantissa *= 256.0;\n\n\tfloat b = floor( mantissa );\n\tmantissa -= b;\n\tmantissa *= 128.0;\n\n\tfloat a = floor( mantissa ) * 2.0 + float( value < 0.0 );\n\n\treturn vec4( r, g, b, a ) / 255.0;\n\n}\n\nfloat unpack( vec4 value ) {\n\n\tfloat r = floor( value.r * 255.0 + 0.5 );\n\tfloat g = floor( value.g * 255.0 + 0.5 );\n\tfloat b = floor( value.b * 255.0 + 0.5 );\n\tfloat a = floor( value.a * 255.0 + 0.5 );\n\n\tfloat exponent = r - 127.0;\n\tfloat sign = 1.0 - mod( a, 2.0 ) * 2.0;\n\tfloat mantissa = float( r > 0.0 ) + g / 256.0 + b / 65536.0\n\t\t+ floor( a / 2.0 ) / 8388608.0;\n\treturn sign * mantissa * exp2( exponent );\n\n}\n\n",pack:function(t,e){var n,i,r,o,a,s,u;e||(e=new Uint8Array(4*t.length));for(var l=0,d=0,c=t.length;l<c;l++)0!==(n=t[l])&&(i=Math.abs(n),r=Math.floor(Math.log2(i)),r+=(o=Math.pow(2,r))<=i/2,a=(r-=o>i)>100?i/1024/Math.pow(2,r-10)-1:i/o-1,e[d]=r+127,a*=256,s=Math.floor(a),e[d+1]=s,a=256*(a-s),u=Math.floor(a),e[d+2]=u,a=128*(a-u),e[d+3]=2*Math.floor(a)+(n<0)),d+=4;return e},unpack:function(t,e){var n,i,r,o,a,s;e||(e=new Float32Array(t.length/4));for(var u=0,l=0,d=t.length;u<d;u+=4)n=t[u],i=t[u+1],r=t[u+2],a=n-127,s=(1-(o=t[u+3])%2*2)*((n>0)+i/256+r/65536+Math.floor(o/2)/8388608)*Math.pow(2,a),e[l]=s,l++}};function w(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function P(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var L=function(){function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.DEFAULT_FRAGMENT,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(w(this,t),!t.renderer)throw new Error("Use TextureComputer.init( renderer ) before instancing.");this._shader=n,this._uniforms=i,this.data=e}var e,n,r;return e=t,(n=[{key:"compute",value:function(){this.renderTarget=this.renderTarget===this._rt1?this._rt2:this._rt1,t.render(this.material,this.renderTarget),this.material.uniforms.tData.value=this.renderTarget.texture}},{key:"fill",value:function(t){this._data.fill(t),S.pack(this._data,this.tData.image.data)}},{key:"dispose",value:function(){this._rt1.dispose(),this._rt2.dispose(),this.tData.dispose()}},{key:"data",get:function(){return t.renderer.readRenderTargetPixels(this.renderTarget,0,0,this._size,this._size,this._buffer),S.unpack(this._buffer,this._data),this._data},set:function(e){var n=Array.isArray(e),i=n?t.getRequiredSize(e.length):t.getRequiredSize(e);this._size=i,this.tData=t.createTexture(i),this._buffer=this.tData.image.data,this._data=n?e:new Float32Array(i*i),n&&S.pack(e,this.tData.image.data),this.uniforms=this._uniforms,this._rt1=t.createRenderTarget(i),this._rt2=t.createRenderTarget(i),this.renderTarget=this._rt1}},{key:"shader",get:function(){return this._shader},set:function(e){this._shader=e,this.material=new i.ShaderMaterial({uniforms:this._uniforms,vertexShader:t.DEFAULT_VERTEX,fragmentShader:e});var n=this.size.toFixed(1);this.material.defines.resolution="vec2( ".concat(n,", ").concat(n," )")}},{key:"uniforms",get:function(){return this._uniforms},set:function(t){t.tData={value:this.tData},this._uniforms=t,this.shader=this._shader}},{key:"size",get:function(){return this._size}},{key:"texture",get:function(){return this.material.uniforms.tData.value}}])&&P(e.prototype,n),r&&P(e,r),t}();L.init=function(t){return L.renderer||(L.renderer=t,L.scene=new i.Scene,L.camera=new i.Camera,L.mesh=new i.Mesh(new i.PlaneBufferGeometry(2,2)),L.scene.add(L.mesh)),L.checkHardwareCompatibility()},L.checkHardwareCompatibility=function(){return L.isCompatible=!0,0===L.renderer.capabilities.maxVertexTextures&&(console.warn("No support for vertex textures."),L.isCompatible=!1),L.isCompatible||window.alert("Incompatible hardware."),L.isCompatible},L.render=function(t,e){L.mesh.material=t,L.renderer.setRenderTarget(e),L.renderer.render(L.scene,L.camera),L.renderer.setRenderTarget(null)},L.DEFAULT_VERTEX="\n\n    void main() {\n\n        gl_Position = vec4( position, 1.0 );\n\n    }\n\n",L.DEFAULT_FRAGMENT="\n\n    uniform sampler2D tData;\n\n    ".concat(S.GLSL,"\n\n    void main() {\n        \n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        float data = unpack( texture2D( tData, uv ) );\n\n        // Modify data...\n\n        gl_FragColor = pack( data );\n\n    }\n\n"),L.createTexture=function(t){return new i.DataTexture(new Uint8Array(t*t*4),t,t,i.RGBAFormat,i.UnsignedByteType)},L.createRenderTarget=function(t){return new i.WebGLRenderTarget(t,t,{wrapS:i.ClampToEdgeWrapping,wrapT:i.ClampToEdgeWrapping,minFilter:i.NearestFilter,magFilter:i.NearestFilter,stencilBuffer:!1,depthBuffer:!1,format:i.RGBAFormat,type:i.UnsignedByteType})},L.getRequiredSize=function(t){if(isNaN(t)||!isFinite(t)||!Number.isInteger(t)||t<1)throw new RangeError("Length must be a natural number.");for(var e=1,n=2;n*n<t;)n=Math.pow(2,e),e++;return n},L.round=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:6,n=Math.pow(10,e);return Math.round(t*n)/n};class O{constructor(t={}){this.name=t.name,this.type=t.type,this.node=t.node,this.needsUpdate=t.needsUpdate}get value(){return this.node.value}set value(t){this.node.value=t}}const E={elements:["x","y","z","w"],addShortcuts:function(){function t(t,e,n){return n?{get:function(){return this[t][e][n]},set:function(i){this[t][e][n]=i}}:{get:function(){return this[t][e]},set:function(n){this[t][e]=n}}}return function(e,n,i){const r={};for(let e=0;e<i.length;++e){const o=i[e].split("."),a=o[0],s=o[1];r[a]=t(n,a,s)}Object.defineProperties(e,r)}}()},I={nodes:{},keywords:{},add:function(t){this.nodes[t.name]=t},addKeyword:function(t,e,n){n=void 0===n||n,this.keywords[t]={callback:e,cache:n}},remove:function(t){delete this.nodes[t.name]},removeKeyword:function(t){delete this.keywords[t]},get:function(t){return this.nodes[t]},getKeyword:function(t,e){return this.keywords[t].callback.call(this,e)},getKeywordData:function(t){return this.keywords[t]},contains:function(t){return void 0!==this.nodes[t]},containsKeyword:function(t){return void 0!==this.keywords[t]}};class R{constructor(t){this.uuid=i.MathUtils.generateUUID(),this.name="",this.type=t,this.userData={}}analyze(t,e={}){t.analyzing=!0,this.build(t.addFlow(e.slot,e.cache,e.context),"v4"),t.clearVertexNodeCode(),t.clearFragmentNodeCode(),t.removeFlow(),t.analyzing=!1}analyzeAndFlow(t,e,n={}){return this.analyze(t,n),this.flow(t,e,n)}flow(t,e,n={}){t.addFlow(n.slot,n.cache,n.context);const i={};return i.result=this.build(t,e),i.code=t.clearNodeCode(),i.extra=t.context.extra,t.removeFlow(),i}build(t,e,n){e=e||this.getType(t,e);const i=t.getNodeData(n||this);return t.analyzing&&this.appendDepsNode(t,i,e),-1===t.nodes.indexOf(this)&&t.nodes.push(this),void 0!==this.updateFrame&&-1===t.updaters.indexOf(this)&&t.updaters.push(this),this.generate(t,e,n)}generate(){}getHash(){let t,e,n="{";for(t in this)e=this[t],e instanceof R&&(n+='"'+t+'":'+e.getHash()+",");if(this.hashProperties)for(let i=0;i<this.hashProperties.length;i++)t=this.hashProperties[i],e=this[t],n+='"'+t+'":"'+String(e)+'",';return n+='"id":"'+this.uuid+'"}',n}appendDepsNode(t,e,n){e.deps=(e.deps||0)+1;const i=t.getTypeLength(n);(i>(e.outputMax||0)||this.getType(t,n))&&(e.outputMax=i,e.output=n)}setName(t){return this.name=t,this}getName(){return this.name}getType(t,e){return"sampler2D"===e||"samplerCube"===e?e:this.type}getJSONNode(t){if(!(void 0===t||"string"==typeof t)&&void 0!==t.nodes[this.uuid])return t.nodes[this.uuid]}copy(t){return void 0!==t.name&&(this.name=t.name),void 0!==t.userData&&(this.userData=JSON.parse(JSON.stringify(t.userData))),this}createJSONNode(t){const e=void 0===t||"string"==typeof t,n={};if("string"!=typeof this.nodeType)throw new Error("Node does not allow serialization.");return n.uuid=this.uuid,n.nodeType=this.nodeType,""!==this.name&&(n.name=this.name),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e||(t.nodes[this.uuid]=n),n}toJSON(t){return this.getJSONNode(t)||this.createJSONNode(t)}}R.prototype.isNode=!0,R.prototype.hashProperties=void 0;class C extends R{constructor(t,e={}){super(t),this.shared=void 0===e.shared||e.shared,this.unique=void 0!==e.unique&&e.unique}build(t,e,n,r){if(e=e||this.getType(t),this.getShared(t,e)){const o=this.getUnique(t,e);o&&void 0===this.constructor.uuid&&(this.constructor.uuid=i.MathUtils.generateUUID()),n=t.getUuid(n||this.getUuid(),!o);const a=t.getNodeData(n),s=a.output||this.getType(t);if(t.analyzing)return(a.deps||0)>0||this.getLabel()?(this.appendDepsNode(t,a,e),this.generate(t,e,n)):super.build(t,e,n);if(o)return a.name=a.name||super.build(t,e,n),a.name;if(!this.getLabel()&&(!this.getShared(t,s)||t.context.ignoreCache||1===a.deps))return super.build(t,e,n);n=this.getUuid(!1);let u=this.getTemp(t,n);if(u)return t.format(u,s,e);{u=C.prototype.generate.call(this,t,e,n,a.output,r);const i=this.generate(t,s,n);return t.addNodeCode(u+" = "+i+";"),t.format(u,s,e)}}return super.build(t,e,n)}getShared(t,e){return"sampler2D"!==e&&"samplerCube"!==e&&this.shared}getUnique(){return this.unique}setLabel(t){return this.label=t,this}getLabel(){return this.label}getUuid(t){let e=(t||null==t)&&this.constructor.uuid||this.uuid;return"string"==typeof this.scope&&(e=this.scope+"-"+e),e}getTemp(t,e){e=e||this.uuid;const n=t.getVars()[e];return n?n.name:void 0}generate(t,e,n,i,r){return this.getShared(t,e)||console.error("THREE.TempNode is not shared!"),n=n||this.uuid,t.getTempVar(n,i||this.getType(t),r,this.getLabel()).name}}const U=/^\s*([a-z_0-9]+)\s+([a-z_0-9]+)\s*\(([\s\S]*?)\)/i,M=/[a-z_0-9]+/gi;class D extends C{constructor(t,e,n,i,r){super(r),this.isMethod=void 0===r,this.isInterface=!1,this.parse(t,e,n,i)}getShared(){return!this.isMethod}getType(t){return t.getTypeByFormat(this.type)}getInputByName(t){let e=this.inputs.length;for(;e--;)if(this.inputs[e].name===t)return this.inputs[e]}getIncludeByName(t){let e=this.includes.length;for(;e--;)if(this.includes[e].name===t)return this.includes[e]}generate(t,e){let n,i=0,r=this.src;for(let e=0;e<this.includes.length;e++)t.include(this.includes[e],this);for(const e in this.extensions)t.extensions[e]=!0;const o=[];for(;n=M.exec(this.src);)o.push(n);for(let e=0;e<o.length;e++){const n=o[e],a=n[0],s=!this.isMethod||!this.getInputByName(a);let u=a;if(this.keywords[a]||this.useKeywords&&s&&I.containsKeyword(a)){let e=this.keywords[a];if(!e){const n=I.getKeywordData(a);n.cache&&(e=t.keywords[a]),e=e||I.getKeyword(a,t),n.cache&&(t.keywords[a]=e)}u=e.build(t)}a!==u&&(r=r.substring(0,n.index+i)+u+r.substring(n.index+a.length+i),i+=u.length-a.length),void 0===this.getIncludeByName(u)&&I.contains(u)&&t.include(I.get(u))}return"source"===e?r:this.isMethod?(this.isInterface||t.include(this,!1,r),this.name):t.format("( "+r+" )",this.getType(t),e)}parse(t,e,n,i){if(this.src=t||"",this.includes=e||[],this.extensions=n||{},this.keywords=i||{},this.isMethod){const t=this.src.match(U);if(this.inputs=[],t&&4==t.length){this.type=t[1],this.name=t[2];const e=t[3].match(M);if(e){let t=0;for(;t<e.length;){let n,i=e[t++];"in"===i||"out"===i||"inout"===i?n=e[t++]:(n=i,i="");const r=e[t++];this.inputs.push({name:r,type:n,qualifier:i})}}this.isInterface=-1===this.src.indexOf("{")}else this.type="",this.name=""}}copy(t){return super.copy(t),this.isMethod=t.isMethod,this.useKeywords=t.useKeywords,this.parse(t.src,t.includes,t.extensions,t.keywords),void 0!==t.type&&(this.type=t.type),this}toJSON(t){let e=this.getJSONNode(t);if(!e){e=this.createJSONNode(t),e.src=this.src,e.isMethod=this.isMethod,e.useKeywords=this.useKeywords,this.isMethod||(e.type=this.type),e.extensions=JSON.parse(JSON.stringify(this.extensions)),e.keywords={};for(const n in this.keywords)e.keywords[n]=this.keywords[n].toJSON(t).uuid;if(this.includes.length){e.includes=[];for(let n=0;n<this.includes.length;n++)e.includes.push(this.includes[n].toJSON(t).uuid)}}return e}}D.prototype.nodeType="Function",D.prototype.useKeywords=!0;const X=/^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i;class z extends C{constructor(t,e){super(),this.parse(t||z.PI,e)}getType(t){return t.getTypeByFormat(this.type)}parse(t,e){this.src=t||"";let n,i,r="";const o=this.src.match(X);this.useDefine=e||"#"===this.src.charAt(0),o&&o.length>1?(i=o[1],n=o[2],r=o[3]):(n=this.src,i="f"),this.name=n,this.type=i,this.value=r}build(t,e){return"source"!==e?(t.include(this),t.format(this.name,this.getType(t),e)):this.value?this.useDefine?"#define "+this.name+" "+this.value:"const "+this.type+" "+this.name+" = "+this.value+";":this.useDefine?this.src:void 0}generate(t,e){return t.format(this.name,this.getType(t),e)}copy(t){return super.copy(t),this.parse(t.src,t.useDefine),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.src=this.src,!0===e.useDefine&&(e.useDefine=!0)),e}}z.prototype.nodeType="Const",z.PI="PI",z.PI2="PI2",z.RECIPROCAL_PI="RECIPROCAL_PI",z.RECIPROCAL_PI2="RECIPROCAL_PI2",z.LOG2="LOG2",z.EPSILON="EPSILON";const Y=/^struct\s*([a-z_0-9]+)\s*{\s*((.|\n)*?)}/gim,J=/\s*(\w*?)\s*(\w*?)(\=|\;)/gim;class k extends C{constructor(t){super(),this.parse(t)}getType(t){return t.getTypeByFormat(this.name)}getInputByName(t){let e=this.inputs.length;for(;e--;)if(this.inputs[e].name===t)return this.inputs[e]}generate(t,e){return"source"===e?this.src+";":t.format("( "+this.src+" )",this.getType(t),e)}parse(t=""){this.src=t,this.inputs=[];const e=Y.exec(this.src);if(e){const t=e[2];let n;for(;n=J.exec(t);)this.inputs.push({type:n[1],name:n[2]});this.name=e[1]}else this.name="";this.type=this.name}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.src=this.src),e}}k.prototype.nodeType="Struct";class Q extends C{constructor(t,e){(e=e||{}).shared=void 0!==e.shared&&e.shared,super(t,e),this.readonly=!1}setReadonly(t){return this.readonly=t,this.hashProperties=this.readonly?["value"]:void 0,this}getReadonly(){return this.readonly}copy(t){return super.copy(t),void 0!==t.readonly&&(this.readonly=t.readonly),this}createJSONNode(t){const e=super.createJSONNode(t);return!0===this.readonly&&(e.readonly=this.readonly),e}generate(t,e,n,i,r,o){n=t.getUuid(n||this.getUuid()),i=i||this.getType(t);const a=t.getNodeData(n);return this.getReadonly(t)&&void 0!==this.generateReadonly?this.generateReadonly(t,e,n,i,r,o):t.isShader("vertex")?(a.vertex||(a.vertex=t.createVertexUniform(i,this,r,o,this.getLabel())),t.format(a.vertex.name,i,e)):(a.fragment||(a.fragment=t.createFragmentUniform(i,this,r,o,this.getLabel())),t.format(a.fragment.name,i,e))}}class B extends Q{constructor(t,e){super("v2"),this.value=t instanceof i.Vector2?t:new i.Vector2(t,e)}generateReadonly(t,e,n,i){return t.format("vec2( "+this.x+", "+this.y+" )",i,e)}copy(t){return super.copy(t),this.value.copy(t),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.x=this.x,e.y=this.y,!0===this.readonly&&(e.readonly=!0)),e}}B.prototype.nodeType="Vector2",E.addShortcuts(B.prototype,"value",["x","y"]);class H extends Q{constructor(t,e,n){super("v3"),this.value=t instanceof i.Vector3?t:new i.Vector3(t,e,n)}generateReadonly(t,e,n,i){return t.format("vec3( "+this.x+", "+this.y+", "+this.z+" )",i,e)}copy(t){return super.copy(t),this.value.copy(t),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.x=this.x,e.y=this.y,e.z=this.z,!0===this.readonly&&(e.readonly=!0)),e}}H.prototype.nodeType="Vector3",E.addShortcuts(H.prototype,"value",["x","y","z"]);class V extends Q{constructor(t,e,n,r){super("v4"),this.value=t instanceof i.Vector4?t:new i.Vector4(t,e,n,r)}generateReadonly(t,e,n,i){return t.format("vec4( "+this.x+", "+this.y+", "+this.z+", "+this.w+" )",i,e)}copy(t){return super.copy(t),this.value.copy(t),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.x=this.x,e.y=this.y,e.z=this.z,e.w=this.w,!0===this.readonly&&(e.readonly=!0)),e}}V.prototype.nodeType="Vector4",E.addShortcuts(V.prototype,"value",["x","y","z","w"]);class G extends C{constructor(t){super("v2",{shared:!1}),this.index=t||0}generate(t,e){t.requires.uv[this.index]=!0;const n=this.index>0?this.index+1:"",i=t.isShader("vertex")?"uv"+n:"vUv"+n;return t.format(i,this.getType(t),e)}copy(t){return super.copy(t),this.index=t.index,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.index=this.index),e}}G.prototype.nodeType="UV",I.addKeyword("uv",(function(){return new G})),I.addKeyword("uv2",(function(){return new G(1)}));class j extends Q{constructor(t){super("f"),this.value=t||0}generateReadonly(t,e,n,i){return t.format(this.value+(this.value%1?"":".0"),i,e)}copy(t){return super.copy(t),this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value,!0===this.readonly&&(e.readonly=!0)),e}}j.prototype.nodeType="Float";class q extends D{constructor(t,e,n,i,r){super(t,r,i,n,e)}}q.prototype.nodeType="Expression";class W extends C{constructor(t,e){super("v4"),this.input=t,this.method=e||W.LINEAR_TO_LINEAR}generate(t,e){const n=this.input.build(t,"v4"),i=this.getType(t),r=W.Nodes[this.method],o=t.include(r);if(o===W.LINEAR_TO_LINEAR)return t.format(n,i,e);if(2===r.inputs.length){const r=this.factor.build(t,"f");return t.format(o+"( "+n+", "+r+" )",i,e)}return t.format(o+"( "+n+" )",i,e)}fromEncoding(t){const e=W.getEncodingComponents(t);this.method="LinearTo"+e[0],this.factor=e[1]}fromDecoding(t){const e=W.getEncodingComponents(t);this.method=e[0]+"ToLinear",this.factor=e[1]}copy(t){return super.copy(t),this.input=t.input,this.method=t.method,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.input=this.input.toJSON(t).uuid,e.method=this.method),e}}W.Nodes=function(){const t=new D("\n\t\tvec4 LinearToLinear( in vec4 value ) {\n\n\t\t\treturn value;\n\n\t\t}"),e=new D("\n\t\tvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\n\t\t\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n\n\t\t}"),n=new D("\n\t\tvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\n\t\t\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n\n\t\t}"),i=new D("\n\t\tvec4 sRGBToLinear( in vec4 value ) {\n\n\t\t\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n\n\t\t}"),r=new D("\n\t\tvec4 LinearTosRGB( in vec4 value ) {\n\n\t\t\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n\n\t\t}"),o=new D("\n\t\tvec4 RGBEToLinear( in vec4 value ) {\n\n\t\t\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n\n\t\t}"),a=new D("\n\t\tvec4 LinearToRGBE( in vec4 value ) {\n\n\t\t\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\t\t\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\t\t\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n\n\t\t}"),s=new D("\n\t\tvec3 RGBMToLinear( in vec4 value, in float maxRange ) {\n\n\t\t\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n\n\t\t}"),u=new D("\n\t\tvec3 LinearToRGBM( in vec4 value, in float maxRange ) {\n\n\t\t\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\t\t\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\t\t\tM            = ceil( M * 255.0 ) / 255.0;\n\t\t\treturn vec4( value.rgb / ( M * maxRange ), M );\n\n\t\t}"),l=new D("\n\t\tvec3 RGBDToLinear( in vec4 value, in float maxRange ) {\n\n\t\t\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n\n\t\t}"),d=new D("\n\t\tvec3 LinearToRGBD( in vec4 value, in float maxRange ) {\n\n\t\t\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\t\t\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\t\t\tD            = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\t\t\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n\n\t\t}"),c=new z("const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );"),h=new D("\n\t\tvec4 LinearToLogLuv( in vec4 value ) {\n\n\t\t\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\t\t\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\t\t\tvec4 vResult;\n\t\t\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\t\t\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\t\t\tvResult.w = fract(Le);\n\t\t\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\t\t\treturn vResult;\n\n\t\t}",[c]),f=new z("const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );");return{LinearToLinear:t,GammaToLinear:e,LinearToGamma:n,sRGBToLinear:i,LinearTosRGB:r,RGBEToLinear:o,LinearToRGBE:a,RGBMToLinear:s,LinearToRGBM:u,RGBDToLinear:l,LinearToRGBD:d,cLogLuvM:c,LinearToLogLuv:h,cLogLuvInverseM:f,LogLuvToLinear:new D("\n\t\tvec4 LogLuvToLinear( in vec4 value ) {\n\n\t\t\tfloat Le = value.z * 255.0 + value.w;\n\t\t\tvec3 Xp_Y_XYZp;\n\t\t\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\t\t\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\t\t\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\t\t\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\t\t\treturn vec4( max(vRGB, 0.0), 1.0 );\n\n\t\t}",[f])}}(),W.LINEAR_TO_LINEAR="LinearToLinear",W.GAMMA_TO_LINEAR="GammaToLinear",W.LINEAR_TO_GAMMA="LinearToGamma",W.SRGB_TO_LINEAR="sRGBToLinear",W.LINEAR_TO_SRGB="LinearTosRGB",W.RGBE_TO_LINEAR="RGBEToLinear",W.LINEAR_TO_RGBE="LinearToRGBE",W.RGBM_TO_LINEAR="RGBMToLinear",W.LINEAR_TO_RGBM="LinearToRGBM",W.RGBD_TO_LINEAR="RGBDToLinear",W.LINEAR_TO_RGBD="LinearToRGBD",W.LINEAR_TO_LOG_LUV="LinearToLogLuv",W.LOG_LUV_TO_LINEAR="LogLuvToLinear",W.getEncodingComponents=function(t){switch(t){case i.LinearEncoding:return["Linear"];case i.sRGBEncoding:return["sRGB"];case i.RGBEEncoding:return["RGBE"];case i.RGBM7Encoding:return["RGBM",new j(7).setReadonly(!0)];case i.RGBM16Encoding:return["RGBM",new j(16).setReadonly(!0)];case i.RGBDEncoding:return["RGBD",new j(256).setReadonly(!0)];case i.GammaEncoding:return["Gamma",new q("float( GAMMA_FACTOR )","f")]}},W.prototype.nodeType="ColorSpace",W.prototype.hashProperties=["method"];class K extends Q{constructor(t,e,n,i){super("v4",{shared:!0}),this.value=t,this.uv=e||new G,this.bias=n,this.project=void 0!==i&&i}getTexture(t,e){return super.generate(t,e,this.value.uuid,"t")}generate(t,e){if("sampler2D"===e)return this.getTexture(t,e);const n=this.getTexture(t,e),i=this.uv.build(t,this.project?"v4":"v2");let r,o,a=this.bias?this.bias.build(t,"f"):void 0;void 0===a&&t.context.bias&&(a=t.context.bias.setTexture(this).build(t,"f")),r=this.project?"texture2DProj":a?"tex2DBias":"tex2D",o=a?r+"( "+n+", "+i+", "+a+" )":r+"( "+n+", "+i+" )";const s={include:t.isShader("vertex"),ignoreCache:!0},u=this.getType(t);return t.addContext(s),this.colorSpace=this.colorSpace||new W(new q("",u)),this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(o),o=this.colorSpace.build(t,u),t.removeContext(),t.format(o,u,e)}copy(t){return super.copy(t),t.value&&(this.value=t.value),this.uv=t.uv,t.bias&&(this.bias=t.bias),void 0!==t.project&&(this.project=t.project),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),this.value&&(e.value=this.value.uuid),e.uv=this.uv.toJSON(t).uuid,e.project=this.project,this.bias&&(e.bias=this.bias.toJSON(t).uuid)),e}}K.prototype.nodeType="Texture";class Z extends C{constructor(t){super("v3"),this.scope=t||Z.LOCAL}getType(){return this.scope===Z.PROJECTION?"v4":this.type}getShared(){switch(this.scope){case Z.LOCAL:case Z.WORLD:return!1}return!0}generate(t,e){let n;switch(this.scope){case Z.LOCAL:t.isShader("vertex")?n="transformed":(t.requires.position=!0,n="vPosition");break;case Z.WORLD:if(t.isShader("vertex"))return"( modelMatrix * vec4( transformed, 1.0 ) ).xyz";t.requires.worldPosition=!0,n="vWPosition";break;case Z.VIEW:n=t.isShader("vertex")?"-mvPosition.xyz":"vViewPosition";break;case Z.PROJECTION:n=t.isShader("vertex")?"( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )":"vec4( 0.0 )"}return t.format(n,this.getType(t),e)}copy(t){return super.copy(t),this.scope=t.scope,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.scope=this.scope),e}}Z.LOCAL="local",Z.WORLD="world",Z.VIEW="view",Z.PROJECTION="projection",Z.prototype.nodeType="Position",I.addKeyword("position",(function(){return new Z})),I.addKeyword("worldPosition",(function(){return new Z(Z.WORLD)})),I.addKeyword("viewPosition",(function(){return new Z(Z.VIEW)}));class $ extends C{constructor(t){super("v3"),this.scope=t||$.VIEW}getShared(){return this.scope===$.WORLD}build(t,e,n,i){const r=t.context[this.scope+"Normal"];return r?r.build(t,e,n,i):super.build(t,e,n)}generate(t,e){let n;switch(this.scope){case $.VIEW:n=t.isShader("vertex")?"transformedNormal":"geometryNormal";break;case $.LOCAL:t.isShader("vertex")?n="objectNormal":(t.requires.normal=!0,n="vObjectNormal");break;case $.WORLD:t.isShader("vertex")?n="inverseTransformDirection( transformedNormal, viewMatrix ).xyz":(t.requires.worldNormal=!0,n="vWNormal")}return t.format(n,this.getType(t),e)}copy(t){return super.copy(t),this.scope=t.scope,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.scope=this.scope),e}}$.LOCAL="local",$.WORLD="world",$.VIEW="view",$.prototype.nodeType="Normal",I.addKeyword("viewNormal",(function(){return new $($.VIEW)})),I.addKeyword("localNormal",(function(){return new $($.NORMAL)})),I.addKeyword("worldNormal",(function(){return new $($.WORLD)}));class tt extends C{constructor(t){super("v3"),this.scope=t||tt.CUBE}getUnique(t){return!t.context.viewNormal}getType(){return this.scope===tt.SPHERE?"v2":this.type}generate(t,e){const n=this.getUnique(t);if(t.isShader("fragment")){let i,r,o;switch(this.scope){case tt.VECTOR:const e=new $($.VIEW),a=t.context.roughness,s=e.build(t,"v3"),u=new Z(Z.VIEW).build(t,"v3"),l=a?a.build(t,"f"):void 0;let d=`reflect( -normalize( ${u} ), ${s} )`;l&&(d=`normalize( mix( ${d}, ${s}, ${l} * ${l} ) )`),r=`inverseTransformDirection( ${d}, viewMatrix )`,n?(t.addNodeCode(`vec3 reflectVec = ${r};`),i="reflectVec"):i=r;break;case tt.CUBE:o=new tt(tt.VECTOR).build(t,"v3"),r="vec3( -"+o+".x, "+o+".yz )",n?(t.addNodeCode(`vec3 reflectCubeVec = ${r};`),i="reflectCubeVec"):i=r;break;case tt.SPHERE:o=new tt(tt.VECTOR).build(t,"v3"),r="normalize( ( viewMatrix * vec4( "+o+", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5",n?(t.addNodeCode(`vec2 reflectSphereVec = ${r};`),i="reflectSphereVec"):i=r}return t.format(i,this.getType(t),e)}return console.warn("THREE.ReflectNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.type,e)}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.scope=this.scope),e}}tt.CUBE="cube",tt.SPHERE="sphere",tt.VECTOR="vector",tt.prototype.nodeType="Reflect";class et extends Q{constructor(t,e,n){super("v4",{shared:!0}),this.value=t,this.uv=e||new tt,this.bias=n}getTexture(t,e){return super.generate(t,e,this.value.uuid,"tc")}generate(t,e){if("samplerCube"===e)return this.getTexture(t,e);const n=this.getTexture(t,e),i=this.uv.build(t,"v3");let r,o=this.bias?this.bias.build(t,"f"):void 0;void 0===o&&t.context.bias&&(o=t.context.bias.setTexture(this).build(t,"f")),r=o?"texCubeBias( "+n+", "+i+", "+o+" )":"texCube( "+n+", "+i+" )";const a={include:t.isShader("vertex"),ignoreCache:!0},s=this.getType(t);return t.addContext(a),this.colorSpace=this.colorSpace||new W(new q("",s)),this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(r),r=this.colorSpace.build(t,s),t.removeContext(),t.format(r,s,e)}copy(t){return super.copy(t),t.value&&(this.value=t.value),this.uv=t.uv,t.bias&&(this.bias=t.bias),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.uuid,e.uv=this.uv.toJSON(t).uuid,this.bias&&(e.bias=this.bias.toJSON(t).uuid)),e}}et.prototype.nodeType="CubeTexture";class nt extends C{constructor(t,e){super(),this.setFunction(t,e)}setFunction(t,e=[]){this.value=t,this.inputs=e}getFunction(){return this.value}getType(t){return this.value.getType(t)}generate(t,e){const n=this.getType(t),i=this.value;let r=i.build(t,e)+"( ";const o=[];for(let e=0;e<i.inputs.length;e++){const n=i.inputs[e],r=this.inputs[e]||this.inputs[n.name];o.push(r.build(t,t.getTypeByFormat(n.type)))}return r+=o.join(", ")+" )",t.format(r,n,e)}copy(t){super.copy(t);for(const e in t.inputs)this.inputs[e]=t.inputs[e];return this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);if(!e){const n=this.value;if(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,n.inputs.length){e.inputs={};for(let i=0;i<n.inputs.length;i++){const r=n.inputs[i],o=this.inputs[i]||this.inputs[r.name];e.inputs[r.name]=o.toJSON(t).uuid}}}return e}}nt.prototype.nodeType="FunctionCall";class it extends C{constructor(t,e,n){super(),this.a=t,this.b=e,this.op=n}getType(t){const e=this.a.getType(t),n=this.b.getType(t);return t.isTypeMatrix(e)?"v4":t.getTypeLength(n)>t.getTypeLength(e)?n:e}generate(t,e){const n=this.getType(t),i=this.a.build(t,n),r=this.b.build(t,n);return t.format("( "+i+" "+this.op+" "+r+" )",n,e)}copy(t){return super.copy(t),this.a=t.a,this.b=t.b,this.op=t.op,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.a=this.a.toJSON(t).uuid,e.b=this.b.toJSON(t).uuid,e.op=this.op),e}}it.ADD="+",it.SUB="-",it.MUL="*",it.DIV="/",it.prototype.nodeType="Operator";class rt extends C{constructor(t,e,n,i){super(),this.a=t,"string"!=typeof e?this.b=e:i=e,"string"!=typeof n?this.c=n:i=n,this.method=i}getNumInputs(){switch(this.method){case rt.MIX:case rt.CLAMP:case rt.REFRACT:case rt.SMOOTHSTEP:case rt.FACEFORWARD:return 3;case rt.MIN:case rt.MAX:case rt.MOD:case rt.STEP:case rt.REFLECT:case rt.DISTANCE:case rt.DOT:case rt.CROSS:case rt.POW:return 2;default:return 1}}getInputType(t){const e=t.getTypeLength(this.a.getType(t)),n=this.b?t.getTypeLength(this.b.getType(t)):0,i=this.c?t.getTypeLength(this.c.getType(t)):0;return e>n&&e>i?this.a.getType(t):n>i?this.b.getType(t):this.c.getType(t)}getType(t){switch(this.method){case rt.LENGTH:case rt.DISTANCE:case rt.DOT:return"f";case rt.CROSS:return"v3"}return this.getInputType(t)}generate(t,e){let n,i,r;const o=this.a?t.getTypeLength(this.a.getType(t)):0,a=this.b?t.getTypeLength(this.b.getType(t)):0,s=this.c?t.getTypeLength(this.c.getType(t)):0,u=this.getInputType(t),l=this.getType(t);switch(this.method){case rt.NEGATE:return t.format("( -"+this.a.build(t,u)+" )",u,e);case rt.INVERT:return t.format("( 1.0 - "+this.a.build(t,u)+" )",u,e);case rt.CROSS:n=this.a.build(t,"v3"),i=this.b.build(t,"v3");break;case rt.STEP:n=this.a.build(t,1===o?"f":u),i=this.b.build(t,u);break;case rt.MIN:case rt.MAX:case rt.MOD:n=this.a.build(t,u),i=this.b.build(t,1===a?"f":u);break;case rt.REFRACT:n=this.a.build(t,u),i=this.b.build(t,u),r=this.c.build(t,"f");break;case rt.MIX:n=this.a.build(t,u),i=this.b.build(t,u),r=this.c.build(t,1===s?"f":u);break;default:n=this.a.build(t,u),this.b&&(i=this.b.build(t,u)),this.c&&(r=this.c.build(t,u))}const d=[];d.push(n),i&&d.push(i),r&&d.push(r);const c=this.getNumInputs(t);if(d.length!==c)throw Error(`Arguments not match used in "${this.method}". Require ${c}, currently ${d.length}.`);return t.format(this.method+"( "+d.join(", ")+" )",l,e)}copy(t){return super.copy(t),this.a=t.a,this.b=t.b,this.c=t.c,this.method=t.method,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.a=this.a.toJSON(t).uuid,this.b&&(e.b=this.b.toJSON(t).uuid),this.c&&(e.c=this.c.toJSON(t).uuid),e.method=this.method),e}}rt.RAD="radians",rt.DEG="degrees",rt.EXP="exp",rt.EXP2="exp2",rt.LOG="log",rt.LOG2="log2",rt.SQRT="sqrt",rt.INV_SQRT="inversesqrt",rt.FLOOR="floor",rt.CEIL="ceil",rt.NORMALIZE="normalize",rt.FRACT="fract",rt.SATURATE="saturate",rt.SIN="sin",rt.COS="cos",rt.TAN="tan",rt.ASIN="asin",rt.ACOS="acos",rt.ARCTAN="atan",rt.ABS="abs",rt.SIGN="sign",rt.LENGTH="length",rt.NEGATE="negate",rt.INVERT="invert",rt.MIN="min",rt.MAX="max",rt.MOD="mod",rt.STEP="step",rt.REFLECT="reflect",rt.DISTANCE="distance",rt.DOT="dot",rt.CROSS="cross",rt.POW="pow",rt.MIX="mix",rt.CLAMP="clamp",rt.REFRACT="refract",rt.SMOOTHSTEP="smoothstep",rt.FACEFORWARD="faceforward",rt.prototype.nodeType="Math",rt.prototype.hashProperties=["method"];class ot extends C{constructor(t,e,n){super("v4"),this.value=t,this.uv=e,this.bias=n}bilinearCubeUV(t,e,n,i){const r=new nt(ot.Nodes.bilinearCubeUV,[e,n,i]);this.colorSpaceTL=this.colorSpaceTL||new W(new q("","v4")),this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(r.build(t)+".tl"),this.colorSpaceTR=this.colorSpaceTR||new W(new q("","v4")),this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(r.build(t)+".tr"),this.colorSpaceBL=this.colorSpaceBL||new W(new q("","v4")),this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(r.build(t)+".bl"),this.colorSpaceBR=this.colorSpaceBR||new W(new q("","v4")),this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(r.build(t)+".br");const o={include:t.isShader("vertex"),ignoreCache:!0};t.addContext(o),this.colorSpaceTLExp=new q(this.colorSpaceTL.build(t,"v4"),"v4"),this.colorSpaceTRExp=new q(this.colorSpaceTR.build(t,"v4"),"v4"),this.colorSpaceBLExp=new q(this.colorSpaceBL.build(t,"v4"),"v4"),this.colorSpaceBRExp=new q(this.colorSpaceBR.build(t,"v4"),"v4"),t.removeContext();const a=new q("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return a.keywords.cubeUV_TL=this.colorSpaceTLExp,a.keywords.cubeUV_TR=this.colorSpaceTRExp,a.keywords.cubeUV_BL=this.colorSpaceBLExp,a.keywords.cubeUV_BR=this.colorSpaceBRExp,a.keywords.cubeUV=r,a}generate(t,e){if(t.isShader("fragment")){const n=this.uv,i=this.bias||t.context.roughness,r=new nt(ot.Nodes.roughnessToMip,[i]),o=new rt(r,ot.Nodes.m0,ot.Nodes.cubeUV_maxMipLevel,rt.CLAMP),a=new rt(o,rt.FLOOR),s=new rt(o,rt.FRACT),u=this.bilinearCubeUV(t,this.value,n,a),l=this.bilinearCubeUV(t,this.value,n,new it(a,new j(1).setReadonly(!0),it.ADD)),d=new rt(u,l,s,rt.MIX);return t.format(d.build(t),"v4",e)}return console.warn("THREE.TextureCubeUVNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,e.uv=this.uv.toJSON(t).uuid,e.bias=this.bias.toJSON(t).uuid),e}}ot.Nodes=function(){const t=new k("struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}"),e=new z("float cubeUV_maxMipLevel 8.0",!0),n=new z("float cubeUV_minMipLevel 4.0",!0),i=new z("float cubeUV_maxTileSize 256.0",!0),r=new z("float cubeUV_minTileSize 16.0",!0),o=new D("float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}");o.useKeywords=!1;const a=new D("vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}");a.useKeywords=!1;const s=new D("TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}",[t,o,a,e,n,i,r]);s.useKeywords=!1;const u=new z("float r0 1.0",!0),l=new z("float v0 0.339",!0),d=new z("float m0 -2.0",!0),c=new z("float r1 0.8",!0),h=new z("float v1 0.276",!0),f=new z("float m1 -1.0",!0),p=new z("float r4 0.4",!0),m=new z("float v4 0.046",!0),g=new z("float m4 2.0",!0),v=new z("float r5 0.305",!0),x=new z("float v5 0.016",!0),y=new z("float m5 3.0",!0),A=new z("float r6 0.21",!0),b=new z("float v6 0.0038",!0),_=new z("float m6 4.0",!0);return{bilinearCubeUV:s,roughnessToMip:new D("float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}",[u,l,d,c,h,f,p,m,g,v,x,y,A,b,_]),m0:d,cubeUV_maxMipLevel:e}}(),ot.prototype.nodeType="TextureCubeUV";class at extends C{constructor(t,e,n){super("v4"),this.value=t,this.radianceNode=new ot(this.value,e||new tt(tt.VECTOR),n),this.irradianceNode=new ot(this.value,new $($.WORLD),new j(1).setReadonly(!0))}generate(t,e){if(t.isShader("fragment")){t.require("irradiance"),t.context.bias&&t.context.bias.setTexture(this.value);return("irradiance"===t.slot?this.irradianceNode:this.radianceNode).build(t,e)}return console.warn("THREE.TextureCubeNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)}copy(t){return super.copy(t),this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid),e}}at.prototype.nodeType="TextureCube";const st=E.elements,ut=["float","vec2","vec3","vec4"],lt={float:"f",vec2:"v2",vec3:"v3",vec4:"v4",mat4:"v4",int:"i",bool:"b"},dt={t:"sampler2D",tc:"samplerCube",b:"bool",i:"int",f:"float",c:"vec3",v2:"vec2",v3:"vec3",v4:"vec4",m3:"mat3",m4:"mat4"};class ct{constructor(){this.slots=[],this.caches=[],this.contexts=[],this.keywords={},this.nodeData={},this.requires={uv:[],color:[],lights:!1,fog:!1,transparent:!1,irradiance:!1},this.includes={consts:[],functions:[],structs:[]},this.attributes={},this.prefixCode="\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\t#define texCube(a, b) textureCube(a, b)\n\t\t\t\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\n\n\t\t\t\t#define tex2D(a, b) texture2D(a, b)\n\t\t\t\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\n\n\t\t\t#else\n\n\t\t\t\t#define texCube(a, b) textureCube(a, b)\n\t\t\t\t#define texCubeBias(a, b, c) textureCube(a, b, c)\n\n\t\t\t\t#define tex2D(a, b) texture2D(a, b)\n\t\t\t\t#define tex2DBias(a, b, c) texture2D(a, b, c)\n\n\t\t\t#endif\n\n\t\t\t#include <packing>\n\t\t\t#include <common>",this.parsCode={vertex:"",fragment:""},this.code={vertex:"",fragment:""},this.nodeCode={vertex:"",fragment:""},this.resultCode={vertex:"",fragment:""},this.finalCode={vertex:"",fragment:""},this.inputs={uniforms:{list:[],vertex:[],fragment:[]},vars:{varying:[],vertex:[],fragment:[]}},this.defines={},this.uniforms={},this.extensions={},this.updaters=[],this.nodes=[],this.analyzing=!1}build(t,e){this.buildShader("vertex",t),this.buildShader("fragment",e);for(let t=0;t<this.requires.uv.length;t++)if(this.requires.uv[t]){const e=t>0?t+1:"";this.addVaryCode("varying vec2 vUv"+e+";"),t>0&&this.addVertexParsCode("attribute vec2 uv"+e+";"),this.addVertexFinalCode("vUv"+e+" = uv"+e+";")}return this.requires.color[0]&&(this.addVaryCode("varying vec4 vColor;"),this.addVertexParsCode("attribute vec4 color;"),this.addVertexFinalCode("vColor = color;")),this.requires.color[1]&&(this.addVaryCode("varying vec4 vColor2;"),this.addVertexParsCode("attribute vec4 color2;"),this.addVertexFinalCode("vColor2 = color2;")),this.requires.position&&(this.addVaryCode("varying vec3 vPosition;"),this.addVertexFinalCode("vPosition = transformed;")),this.requires.worldPosition&&(this.addVaryCode("varying vec3 vWPosition;"),this.addVertexFinalCode("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;")),this.requires.normal&&(this.addVaryCode("varying vec3 vObjectNormal;"),this.addVertexFinalCode("vObjectNormal = normal;")),this.requires.worldNormal&&(this.addVaryCode("varying vec3 vWNormal;"),this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")),this}buildShader(t,e){this.resultCode[t]=e.build(this.setShader(t),"v4")}setMaterial(t,e){return this.material=t,this.renderer=e,this.requires.lights=t.lights,this.requires.fog=t.fog,this.mergeDefines(t.defines),this}addFlow(t,e,n){return this.addSlot(t).addCache(e).addContext(n)}removeFlow(){return this.removeSlot().removeCache().removeContext()}addCache(t){return this.cache=t||"",this.caches.push(this.cache),this}removeCache(){return this.caches.pop(),this.cache=this.caches[this.caches.length-1]||"",this}addContext(t){return this.context=Object.assign({},this.context,t),this.context.extra=this.context.extra||{},this.contexts.push(this.context),this}removeContext(){return this.contexts.pop(),this.context=this.contexts[this.contexts.length-1]||{},this}addSlot(t=""){return this.slot=t,this.slots.push(this.slot),this}removeSlot(){return this.slots.pop(),this.slot=this.slots[this.slots.length-1]||"",this}addVertexCode(t){this.addCode(t,"vertex")}addFragmentCode(t){this.addCode(t,"fragment")}addCode(t,e){this.code[e||this.shader]+=t+"\n"}addVertexNodeCode(t){this.addNodeCode(t,"vertex")}addFragmentNodeCode(t){this.addNodeCode(t,"fragment")}addNodeCode(t,e){this.nodeCode[e||this.shader]+=t+"\n"}clearNodeCode(t){t=t||this.shader;const e=this.nodeCode[t];return this.nodeCode[t]="",e}clearVertexNodeCode(){return this.clearNodeCode("vertex")}clearFragmentNodeCode(){return this.clearNodeCode("fragment")}addVertexFinalCode(t){this.addFinalCode(t,"vertex")}addFragmentFinalCode(t){this.addFinalCode(t,"fragment")}addFinalCode(t,e){this.finalCode[e||this.shader]+=t+"\n"}addVertexParsCode(t){this.addParsCode(t,"vertex")}addFragmentParsCode(t){this.addParsCode(t,"fragment")}addParsCode(t,e){this.parsCode[e||this.shader]+=t+"\n"}addVaryCode(t){this.addVertexParsCode(t),this.addFragmentParsCode(t)}isCache(t){return-1!==this.caches.indexOf(t)}isSlot(t){return-1!==this.slots.indexOf(t)}define(t,e){this.defines[t]=void 0===e?1:e}require(t){this.requires[t]=!0}isDefined(t){return void 0!==this.defines[t]}getVar(t,e,n,i="varying",r="V",o=""){const a=this.getVars(i);let s=a[t];if(!s){const i=a.length;s={name:n||"node"+r+i+(o?"_"+o:""),type:e},a.push(s),a[t]=s}return s}getTempVar(t,e,n,i){return this.getVar(t,e,n,this.shader,"T",i)}getAttribute(t,e){if(!this.attributes[t]){const n=this.getVar(t,e);this.addVertexParsCode("attribute "+e+" "+t+";"),this.addVertexFinalCode(n.name+" = "+t+";"),this.attributes[t]={varying:n,name:t,type:e}}return this.attributes[t]}getCode(t){return[this.prefixCode,this.parsCode[t],this.getVarListCode(this.getVars("varying"),"varying"),this.getVarListCode(this.inputs.uniforms[t],"uniform"),this.getIncludesCode("consts",t),this.getIncludesCode("structs",t),this.getIncludesCode("functions",t),"void main() {",this.getVarListCode(this.getVars(t)),this.code[t],this.resultCode[t],this.finalCode[t],"}"].join("\n")}getVarListCode(t,e=""){let n="";for(let i=0,r=t.length;i<r;++i){const r=t[i],o=r.type,a=r.name,s=this.getFormatByType(o);if(void 0===s)throw new Error("Node pars "+s+" not found.");n+=e+" "+s+" "+a+";\n"}return n}getVars(t){return this.inputs.vars[t||this.shader]}getNodeData(t){const e=t.isNode?t.uuid:t;return this.nodeData[e]=this.nodeData[e]||{}}createUniform(t,e,n,i,r,o){const a=this.inputs.uniforms,s=a.list.length,u=new O({type:e,name:i||"nodeU"+s+(o?"_"+o:""),node:n,needsUpdate:r});return a.list.push(u),a[t].push(u),a[t][u.name]=u,this.uniforms[u.name]=u,u}createVertexUniform(t,e,n,i,r){return this.createUniform("vertex",t,e,n,i,r)}createFragmentUniform(t,e,n,i,r){return this.createUniform("fragment",t,e,n,i,r)}include(t,e,n){let i;if(t="string"==typeof t?I.get(t):t,!1===this.context.include)return t.name;t instanceof D?i=this.includes.functions:t instanceof z?i=this.includes.consts:t instanceof k&&(i=this.includes.structs);const r=i[this.shader]=i[this.shader]||[];if(t){let i=r[t.name];if(i||(i=r[t.name]={node:t,deps:[]},r.push(i),i.src=t.build(this,"source")),t instanceof D&&e&&r[e.name]&&-1==r[e.name].deps.indexOf(t)&&(r[e.name].deps.push(t),t.includes&&t.includes.length)){let n=0;do{this.include(t.includes[n++],e)}while(n<t.includes.length)}return n&&(i.src=n),t.name}throw new Error("Include not found.")}colorToVectorProperties(t){return t.replace("r","x").replace("g","y").replace("b","z").replace("a","w")}colorToVector(t){return t.replace(/c/g,"v3")}getIncludes(t,e){return this.includes[t][e||this.shader]}getIncludesCode(t,e){let n=this.getIncludes(t,e);if(!n)return"";let i="";n=n.sort(ht);for(let t=0;t<n.length;t++)n[t].src&&(i+=n[t].src+"\n");return i}getConstructorFromLength(t){return ut[t-1]}isTypeMatrix(t){return/^m/.test(t)}getTypeLength(t){return"f"===t?1:parseInt(this.colorToVector(t).substr(1))}getTypeFromLength(t){return 1===t?"f":"v"+t}findNode(){for(let t=0;t<arguments.length;t++){const e=arguments[t];if(void 0!==e&&e.isNode)return e}}resolve(){for(let t=0;t<arguments.length;t++){const e=arguments[t];if(void 0!==e){if(e.isNode)return e;if(e.isTexture)switch(e.mapping){case i.CubeReflectionMapping:case i.CubeRefractionMapping:return new et(e);case i.CubeUVReflectionMapping:case i.CubeUVRefractionMapping:return new at(new K(e));default:return new K(e)}else{if(e.isVector2)return new B(e);if(e.isVector3)return new H(e);if(e.isVector4)return new V(e)}}}}format(t,e,n){switch(this.colorToVector(n+" <- "+e)){case"f <- v2":case"f <- v3":case"f <- v4":return t+".x";case"f <- i":case"f <- b":return"float( "+t+" )";case"v2 <- f":return"vec2( "+t+" )";case"v2 <- v3":case"v2 <- v4":return t+".xy";case"v2 <- i":case"v2 <- b":case"v3 <- i":case"v3 <- b":return"vec2( float( "+t+" ) )";case"v3 <- f":return"vec3( "+t+" )";case"v3 <- v2":return"vec3( "+t+", 0.0 )";case"v3 <- v4":return t+".xyz";case"v4 <- f":return"vec4( "+t+" )";case"v4 <- v2":return"vec4( "+t+", 0.0, 1.0 )";case"v4 <- v3":return"vec4( "+t+", 1.0 )";case"v4 <- i":case"v4 <- b":return"vec4( float( "+t+" ) )";case"i <- f":case"i <- b":return"int( "+t+" )";case"i <- v2":case"i <- v3":case"i <- v4":return"int( "+t+".x )";case"b <- f":return"( "+t+" != 0.0 )";case"b <- v2":return"( "+t+" != vec2( 0.0 ) )";case"b <- v3":return"( "+t+" != vec3( 0.0 ) )";case"b <- v4":return"( "+t+" != vec4( 0.0 ) )";case"b <- i":return"( "+t+" != 0 )"}return t}getTypeByFormat(t){return lt[t]||t}getFormatByType(t){return dt[t]||t}getUuid(t,e){return(e=void 0===e||e)&&this.cache&&(t=this.cache+"-"+t),t}getElementByIndex(t){return st[t]}getIndexByElement(t){return st.indexOf(t)}isShader(t){return this.shader===t}setShader(t){return this.shader=t,this}mergeDefines(t){for(const e in t)this.defines[e]=t[e];return this.defines}mergeUniform(t){for(const e in t)this.uniforms[e]=t[e];return this.uniforms}getTextureEncodingFromMap(t){let e;return t?t.isTexture?e=t.encoding:t.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=i.LinearEncoding,e===i.LinearEncoding&&this.context.gamma&&(e=i.GammaEncoding),e}}function ht(t,e){return t.deps.length-e.deps.length}class ft extends Q{constructor(t,e,n){super("c"),this.value=t instanceof i.Color?t:new i.Color(t||0,e,n)}generateReadonly(t,e,n,i){return t.format("vec3( "+this.r+", "+this.g+", "+this.b+" )",i,e)}copy(t){return super.copy(t),this.value.copy(t),this}toJSON(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).r=this.r,e.g=this.g,e.b=this.b,!0===this.readonly&&(e.readonly=!0)),e}}ft.prototype.nodeType="Color",E.addShortcuts(ft.prototype,"value",["r","g","b"]);class pt extends R{constructor(t){super("v4"),this.value=t}generate(t){const e=this.value.analyzeAndFlow(t,this.type);let n=e.code+"\n";return t.isShader("vertex")?n+="gl_Position = "+e.result+";":n+="gl_FragColor = "+e.result+";",n}copy(t){return super.copy(t),this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid),e}}pt.prototype.nodeType="Raw";class mt extends i.ShaderMaterial{constructor(t,e){super(),this.vertex=t||new pt(new Z(Z.PROJECTION)),this.fragment=e||new pt(new ft(16711680)),this.updaters=[],this.type="NodeMaterial"}get properties(){return this.fragment.properties}get needsUpdate(){return this.needsCompile}set needsUpdate(t){!0===t&&this.version++,this.needsCompile=t}onBeforeCompile(t,e){this.build({renderer:e}),t.defines=this.defines,t.uniforms=this.uniforms,t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.extensionDerivatives=!0===this.extensions.derivatives,t.extensionFragDepth=!0===this.extensions.fragDepth,t.extensionDrawBuffers=!0===this.extensions.drawBuffers,t.extensionShaderTextureLOD=!0===this.extensions.shaderTextureLOD}customProgramCacheKey(){return this.getHash()}getHash(){let t="{";return t+='"vertex":'+this.vertex.getHash()+",",t+='"fragment":'+this.fragment.getHash(),t+="}",t}updateFrame(t){for(let e=0;e<this.updaters.length;++e)t.updateNode(this.updaters[e])}build(t={}){const e=t.builder||new ct;return e.setMaterial(this,t.renderer),e.build(this.vertex,this.fragment),this.vertexShader=e.getCode("vertex"),this.fragmentShader=e.getCode("fragment"),this.defines=e.defines,this.uniforms=e.uniforms,this.extensions=e.extensions,this.updaters=e.updaters,this.fog=e.requires.fog,this.lights=e.requires.lights,this.transparent=e.requires.transparent||this.blending>i.NormalBlending,this}copy(t){const e=this.uuid;for(const e in t)this[e]=t[e];return this.uuid=e,void 0!==t.userData&&(this.userData=JSON.parse(JSON.stringify(t.userData))),this}toJSON(t){if((void 0===t||"string"==typeof t)&&(t={nodes:{}}),t&&!t.materials&&(t.materials={}),!t.materials[this.uuid]){const e={};e.uuid=this.uuid,e.type=this.type,t.materials[e.uuid]=e,""!==this.name&&(e.name=this.name),void 0!==this.size&&(e.size=this.size),void 0!==this.sizeAttenuation&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==i.NormalBlending&&(e.blending=this.blending),!0===this.flatShading&&(e.flatShading=this.flatShading),this.side!==i.FrontSide&&(e.side=this.side),this.vertexColors!==i.NoColors&&(e.vertexColors=this.vertexColors),this.depthFunc!==i.LessEqualDepth&&(e.depthFunc=this.depthFunc),!1===this.depthTest&&(e.depthTest=this.depthTest),!1===this.depthWrite&&(e.depthWrite=this.depthWrite),1!==this.linewidth&&(e.linewidth=this.linewidth),void 0!==this.dashSize&&(e.dashSize=this.dashSize),void 0!==this.gapSize&&(e.gapSize=this.gapSize),void 0!==this.scale&&(e.scale=this.scale),!0===this.dithering&&(e.dithering=!0),!0===this.wireframe&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(e.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(e.wireframeLinejoin=this.wireframeLinejoin),this.alphaTest>0&&(e.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(e.premultipliedAlpha=this.premultipliedAlpha),!1===this.visible&&(e.visible=!1),"{}"!==JSON.stringify(this.userData)&&(e.userData=this.userData),e.fog=this.fog,e.lights=this.lights,e.vertex=this.vertex.toJSON(t).uuid,e.fragment=this.fragment.toJSON(t).uuid}return t.material=this.uuid,t}}mt.prototype.isNodeMaterial=!0;class gt extends K{constructor(t){super(void 0,t)}getUnique(){return!0}getTexture(t,e){return Q.prototype.generate.call(this,t,e,this.getUuid(),"t","renderTexture")}}gt.prototype.nodeType="Screen";class vt extends b{constructor(){super(),this.name="",this.uuid=i.MathUtils.generateUUID(),this.userData={},this.textureID="renderTexture",this.input=new gt,this.material=new mt,this.needsUpdate=!0}render(){this.needsUpdate&&(this.material.dispose(),this.material.fragment.value=this.input,this.needsUpdate=!1),this.uniforms=this.material.uniforms,super.render(...arguments)}copy(t){return this.input=t.input,this}toJSON(t){if((void 0===t||"string"==typeof t)&&(t={nodes:{}}),t&&!t.passes&&(t.passes={}),!t.passes[this.uuid]){var e={};e.uuid=this.uuid,e.type="NodePass",t.passes[this.uuid]=e,""!==this.name&&(e.name=this.name),"{}"!==JSON.stringify(this.userData)&&(e.userData=this.userData),e.input=this.input.toJSON(t).uuid}return t.pass=this.uuid,t}}(class extends R{constructor(t,e){super(t),this.value=e}getType(t){return t.getTypeByFormat(this.type)}generate(t,e){const n=t.getVar(this.uuid,this.type);return this.value&&t.isShader("vertex")&&t.addNodeCode(n.name+" = "+this.value.build(t,this.getType(t))+";"),t.format(n.name,this.getType(t),e)}copy(t){return super.copy(t),this.type=t.type,this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.type=this.type,this.value&&(e.value=this.value.toJSON(t).uuid)),e}}).prototype.nodeType="Var";(class extends R{constructor(t,e){super(e),this.name=t}getAttributeType(t){return"number"==typeof this.type?t.getConstructorFromLength(this.type):this.type}getType(t){const e=this.getAttributeType(t);return t.getTypeByFormat(e)}generate(t,e){const n=this.getAttributeType(t),i=t.getAttribute(this.name,n),r=t.isShader("vertex")?this.name:i.varying.name;return t.format(r,this.getType(t),e)}copy(t){return super.copy(t),this.type=t.type,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.type=this.type),e}}).prototype.nodeType="Attribute";(class extends Q{constructor(t){super("b"),this.value=Boolean(t)}generateReadonly(t,e,n,i){return t.format(this.value,i,e)}copy(t){return super.copy(t),this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value,!0===this.readonly&&(e.readonly=!0)),e}}).prototype.nodeType="Bool";class xt extends Q{constructor(t){super("i"),this.value=Math.floor(t||0)}generateReadonly(t,e,n,i){return t.format(this.value,i,e)}copy(t){return super.copy(t),this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value,!0===this.readonly&&(e.readonly=!0)),e}}xt.prototype.nodeType="Int";class yt extends Q{constructor(t){super("m3"),this.value=t||new i.Matrix3}get elements(){return this.value.elements}set elements(t){this.value.elements=t}generateReadonly(t,e,n,i){return t.format("mat3( "+this.value.elements.join(", ")+" )",i,e)}copy(t){return super.copy(t),this.value.fromArray(t.elements),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.elements=this.value.elements.concat()),e}}yt.prototype.nodeType="Matrix3";class At extends Q{constructor(t){super("m4"),this.value=t||new i.Matrix4}get elements(){return this.value.elements}set elements(t){this.value.elements=t}generateReadonly(t,e,n,i){return t.format("mat4( "+this.value.elements.join(", ")+" )",i,e)}copy(t){return super.copy(t),this.scope.value.fromArray(t.elements),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.elements=this.value.elements.concat()),e}}At.prototype.nodeType="Matrix4";(class extends C{constructor(t){super("v4"),t&&this.setMirror(t)}setMirror(t){this.mirror=t,this.textureMatrix=new At(this.mirror.material.uniforms.textureMatrix.value),this.localPosition=new Z(Z.LOCAL),this.uv=new it(this.textureMatrix,this.localPosition,it.MUL),this.uvResult=new it(null,this.uv,it.ADD),this.texture=new K(this.mirror.material.uniforms.tDiffuse.value,this.uv,null,!0)}generate(t,e){return t.isShader("fragment")?(this.uvResult.a=this.offset,this.texture.uv=this.offset?this.uvResult:this.uv,"sampler2D"===e?this.texture.build(t,e):t.format(this.texture.build(t,this.type),this.type,e)):(console.warn("THREE.ReflectorNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.type,e))}copy(t){return Q.prototype.copy.call(this,t),this.scope.mirror=t.mirror,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.mirror=this.mirror.uuid,this.offset&&(e.offset=this.offset.toJSON(t).uuid)),e}}).prototype.nodeType="Reflector";class bt extends Q{constructor(t,e,n){super(n),this.object=t,this.property=e}get value(){return this.object[this.property]}set value(t){this.object[this.property]=t}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value,e.property=this.property),e}}bt.prototype.nodeType="Property";(class extends K{constructor(t,e,n,r={}){const o=new i.WebGLRenderTarget(t,e,r);super(o.texture),this.input=n,this.clear=void 0===r.clear||r.clear,this.renderTarget=o,this.material=new mt,this.camera=new i.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new i.Scene,this.quad=new i.Mesh(new i.PlaneGeometry(2,2),this.material),this.quad.frustumCulled=!1,this.scene.add(this.quad),this.render=!0}build(t,e,n){const i=new ct;return i.nodes=t.nodes,i.updaters=t.updaters,this.material.fragment.value=this.input,this.material.build({builder:i}),super.build(t,e,n)}updateFramesaveTo(t){if(this.saveTo.render=!1,this.saveTo!==this.saveToCurrent){this.saveToMaterial&&this.saveToMaterial.dispose();const t=new mt;t.fragment.value=this,t.build();const e=new i.Scene,n=new i.Mesh(new i.PlaneGeometry(2,2),t);n.frustumCulled=!1,e.add(n),this.saveToScene=e,this.saveToMaterial=t}this.saveToCurrent=this.saveTo,t.renderer.setRenderTarget(this.saveTo.renderTarget),this.saveTo.clear&&t.renderer.clear(),t.renderer.render(this.saveToScene,this.camera)}updateFrame(t){t.renderer?(this.saveTo&&!1===this.saveTo.render&&this.updateFramesaveTo(t),this.render&&(this.material.uniforms.renderTexture&&(this.material.uniforms.renderTexture.value=t.renderTexture),t.renderer.setRenderTarget(this.renderTarget),this.clear&&t.renderer.clear(),t.renderer.render(this.scene,this.camera)),this.saveTo&&!0===this.saveTo.render&&this.updateFramesaveTo(t)):console.warn("RTTNode need a renderer in NodeFrame")}copy(t){return super.copy(t),this.saveTo=t.saveTo,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=super.toJSON(t),this.saveTo&&(e.saveTo=this.saveTo.toJSON(t).uuid)),e}}).prototype.nodeType="RTT";var _t=["color","color2"],Nt=["vColor","vColor2"];(class extends C{constructor(t){super("v4",{shared:!1}),this.index=t||0}generate(t,e){t.requires.color[this.index]=!0;const n=t.isShader("vertex")?_t[this.index]:Nt[this.index];return t.format(n,this.getType(t),e)}copy(t){return super.copy(t),this.index=t.index,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.index=this.index),e}}).prototype.nodeType="Colors";class Tt extends C{constructor(t,e){super("v3"),this.setScope(t||Tt.POSITION),this.setCamera(e)}setCamera(t){this.camera=t,this.updateFrame=void 0!==t?this.onUpdateFrame:void 0}setScope(t){if(this.scope===Tt.DEPTH)delete this.near,delete this.far;if(this.scope=t,t===Tt.DEPTH){const t=this.camera;this.near=new j(t?t.near:1),this.far=new j(t?t.far:1200)}}getType(){return this.scope===Tt.DEPTH?"f":this.type}getUnique(){switch(this.scope){case Tt.DEPTH:case Tt.TO_VERTEX:return!0}return!1}getShared(){return this.scope!==Tt.POSITION}generate(t,e){let n;switch(this.scope){case Tt.POSITION:n="cameraPosition";break;case Tt.DEPTH:n=t.include(Tt.Nodes.depthColor)+"( "+this.near.build(t,"f")+", "+this.far.build(t,"f")+" )";break;case Tt.TO_VERTEX:n="normalize( "+new Z(Z.WORLD).build(t,"v3")+" - cameraPosition )"}return t.format(n,this.getType(t),e)}onUpdateFrame(){if(this.scope===Tt.DEPTH){const t=this.camera;this.near.value=t.near,this.far.value=t.far}}copy(t){if(super.copy(t),this.setScope(t.scope),t.camera&&this.setCamera(t.camera),t.scope===Tt.DEPTH)this.near.number=t.near,this.far.number=t.far;return this}toJSON(t){let e=this.getJSONNode(t);if(!e&&(e=this.createJSONNode(t),e.scope=this.scope,this.camera&&(e.camera=this.camera.uuid),this.scope===Tt.DEPTH))e.near=this.near.value,e.far=this.far.value;return e}}Tt.Nodes={depthColor:new D("\n\t\tfloat depthColor( float mNear, float mFar ) {\n\n\t\t\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t\t\t#else\n\n\t\t\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t\t\t#endif\n\n\t\t\treturn 1.0 - smoothstep( mNear, mFar, depth );\n\n\t\t}")},Tt.POSITION="position",Tt.DEPTH="depth",Tt.TO_VERTEX="toVertex",Tt.prototype.nodeType="Camera";class Ft extends C{constructor(t){super("v3",{shared:!1}),this.scope=t||Ft.TOTAL}generate(t,e){return t.isCache("light")?t.format("reflectedLight.directDiffuse",this.type,e):(console.warn('THREE.LightNode is only compatible in "light" channel.'),t.format("vec3( 0.0 )",this.type,e))}copy(t){return super.copy(t),this.scope=t.scope,this}toJSON(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).scope=this.scope),e}}Ft.TOTAL="total",Ft.prototype.nodeType="Light";class St extends B{constructor(){super(),this.size=new i.Vector2}updateFrame(t){if(t.renderer){t.renderer.getSize(this.size);const e=t.renderer.getPixelRatio();this.x=this.size.width*e,this.y=this.size.height*e}else console.warn("ResolutionNode need a renderer in NodeFrame")}copy(t){return super.copy(t),this.renderer=t.renderer,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.renderer=this.renderer.uuid),e}}St.prototype.nodeType="Resolution";(class extends C{constructor(t){super("v2"),this.resolution=t||new St}generate(t,e){let n;return t.isShader("fragment")?n="( gl_FragCoord.xy / "+this.resolution.build(t,"v2")+")":(console.warn("THREE.ScreenUVNode is not compatible with "+t.shader+" shader."),n="vec2( 0.0 )"),t.format(n,this.getType(t),e)}copy(t){return super.copy(t),this.resolution=t.resolution,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.resolution=this.resolution.toJSON(t).uuid),e}}).prototype.nodeType="ScreenUV";class wt extends C{constructor(t,e,n,i,r){super(),this.a=t,this.b=e,this.op=n,this.ifNode=i,this.elseNode=r}getType(t){if(this.ifNode){const e=this.ifNode.getType(t),n=this.elseNode.getType(t);return t.getTypeLength(n)>t.getTypeLength(e)?n:e}return"b"}getCondType(t){return t.getTypeLength(this.b.getType(t))>t.getTypeLength(this.a.getType(t))?this.b.getType(t):this.a.getType(t)}generate(t,e){const n=this.getType(t),i=this.getCondType(t),r=this.a.build(t,i),o=this.b.build(t,i);let a;if(this.ifNode){const e=this.ifNode.build(t,n),i=this.elseNode.build(t,n);a="( "+[r,this.op,o,"?",e,":",i].join(" ")+" )"}else a="( "+r+" "+this.op+" "+o+" )";return t.format(a,this.getType(t),e)}copy(t){return super.copy(t),this.a=t.a,this.b=t.b,this.op=t.op,this.ifNode=t.ifNode,this.elseNode=t.elseNode,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.a=this.a.toJSON(t).uuid,e.b=this.b.toJSON(t).uuid,e.op=this.op,e.ifNode&&(e.ifNode=this.ifNode.toJSON(t).uuid),e.elseNode&&(e.elseNode=this.elseNode.toJSON(t).uuid)),e}}wt.EQUAL="==",wt.NOT_EQUAL="!=",wt.GREATER=">",wt.GREATER_EQUAL=">=",wt.LESS="<",wt.LESS_EQUAL="<=",wt.AND="&&",wt.OR="||",wt.prototype.nodeType="Cond";const Pt="\nvec3 mod289( vec3 x ) {\n\n\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec4 mod289( vec4 x ) {\n\n\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec4 permute( vec4 x ) {\n\n\treturn mod289( ( ( x * 34.0 ) + 1.0 ) * x );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nvec2 fade( vec2 t ) {\n\n\treturn t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec3 fade( vec3 t ) {\n\n\treturn t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n".trim(),Lt="\nfloat noise2d( vec2 P, float amplitude, float pivot ) {\n\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod289(Pi); // To avoid truncation effects in permutation\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\n\tvec4 i = permute(permute(ix) + iy);\n\n\tvec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\tvec4 gy = abs(gx) - 0.5 ;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\n\tvec2 g00 = vec2(gx.x,gy.x);\n\tvec2 g10 = vec2(gx.y,gy.y);\n\tvec2 g01 = vec2(gx.z,gy.z);\n\tvec2 g11 = vec2(gx.w,gy.w);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy * amplitude + pivot;\n\n}\n".trim();class Ot extends C{constructor(t=new G,e=new j(1),n=new j(0)){super("f"),this.uv=t,this.amplitude=e,this.pivot=n}generate(t,e){const n=new nt(Ot.Nodes.noise2d,[this.uv,this.amplitude,this.pivot]);return t.format(n.generate(t,e),this.getType(t),e)}copy(t){super.copy(t),this.uv=t.uv,this.amplitude=t.amplitude,this.pivot=t.pivot}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.uv=this.uv.toJSON(t).uuid,e.amplitude=this.amplitude.toJSON(t).uuid,e.pivot=this.pivot.toJSON(t).uuid),e}}Ot.prototype.nodeType="Noise2D",Ot.Nodes=function(){const t=new D(Pt),e=new D(Lt);return e.includes=[t],{noiseCommon:t,noise2d:e}}();const Et="\nfloat noise3d( vec3 P, float amplitude, float pivot ) {\n\n\tvec3 Pi0 = floor(P); // Integer part for indexing\n\tvec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n\tPi0 = mod289(Pi0);\n\tPi1 = mod289(Pi1);\n\tvec3 Pf0 = fract(P); // Fractional part for interpolation\n\tvec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\tvec4 iy = vec4(Pi0.yy, Pi1.yy);\n\tvec4 iz0 = Pi0.zzzz;\n\tvec4 iz1 = Pi1.zzzz;\n\n\tvec4 ixy = permute(permute(ix) + iy);\n\tvec4 ixy0 = permute(ixy + iz0);\n\tvec4 ixy1 = permute(ixy + iz1);\n\n\tvec4 gx0 = ixy0 * (1.0 / 7.0);\n\tvec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\tgx0 = fract(gx0);\n\tvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\tvec4 sz0 = step(gz0, vec4(0.0));\n\tgx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\tgy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\tvec4 gx1 = ixy1 * (1.0 / 7.0);\n\tvec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\tgx1 = fract(gx1);\n\tvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\tvec4 sz1 = step(gz1, vec4(0.0));\n\tgx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\tgy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\tvec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\tvec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\tvec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\tvec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\tvec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\tvec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\tvec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\tvec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n\tvec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\tg000 *= norm0.x;\n\tg010 *= norm0.y;\n\tg100 *= norm0.z;\n\tg110 *= norm0.w;\n\tvec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\tg001 *= norm1.x;\n\tg011 *= norm1.y;\n\tg101 *= norm1.z;\n\tg111 *= norm1.w;\n\n\tfloat n000 = dot(g000, Pf0);\n\tfloat n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\tfloat n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\tfloat n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\tfloat n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\tfloat n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\tfloat n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\tfloat n111 = dot(g111, Pf1);\n\n\tvec3 fade_xyz = fade(Pf0);\n\tvec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\tvec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\tfloat n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\treturn 2.2 * n_xyz * amplitude + pivot;\n\n}\n".trim();class It extends C{constructor(t=new Z,e=new j(1),n=new j(0)){super("f"),this.position=t,this.amplitude=e,this.pivot=n}generate(t,e){const n=new nt(It.Nodes.noise3d,[this.position,this.amplitude,this.pivot]);return t.format(n.generate(t,e),this.getType(t),e)}copy(t){super.copy(t),this.position=t.position,this.amplitude=t.amplitude,this.pivot=t.pivot}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.position=this.position.toJSON(t).uuid,e.amplitude=this.amplitude.toJSON(t).uuid,e.pivot=this.pivot.toJSON(t).uuid),e}}It.prototype.nodeType="Noise3D",It.Nodes=function(){const t=new D(Et);return t.includes=[Ot.Nodes.noiseCommon],{noise3d:t}}();class Rt extends C{constructor(t){super("f"),this.uv=t||new G}generate(t,e){const n=t.include(Rt.Nodes.checker);return t.format(n+"( "+this.uv.build(t,"v2")+" )",this.getType(t),e)}copy(t){return super.copy(t),this.uv=t.uv,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.uv=this.uv.toJSON(t).uuid),e}}Rt.Nodes={checker:new D("\n\t\tfloat checker( vec2 uv ) {\n\n\t\t\tfloat cx = floor( uv.x );\n\t\t\tfloat cy = floor( uv.y );\n\t\t\tfloat result = mod( cx + cy, 2.0 );\n\n\t\t\treturn sign( result );\n\n\t\t}")},Rt.prototype.nodeType="Noise";const Ct="\nfloat fractal3d( vec3 p, float amplitude, int octaves, float lacunarity, float diminish ) {\n\n\tfloat result = 0.0;\n\n\tfor (int i = 0;  i < octaves; ++i) {\n\n\t\tresult += noise3d(p, amplitude, 0.0);\n\t\tamplitude *= diminish;\n\t\tp *= lacunarity;\n\n\t}\n\n\treturn result;\n\n}\n".trim();class Ut extends C{constructor(t=new Z,e=new j(1),n=3,i=2,r=.5){super("f"),this.position=t,this.amplitude=e,this.octaves=new xt(n).setReadonly(!0),this.lacunarity=new j(i).setReadonly(!0),this.diminish=new j(r).setReadonly(!0)}generate(t,e){const n=new nt(Ut.Nodes.fractal3d,[this.position,this.amplitude,this.octaves,this.lacunarity,this.diminish]);return t.format(n.generate(t,e),this.getType(t),e)}copy(t){super.copy(t),this.position=t.position,this.amplitude=t.amplitude,this.octaves=t.octaves,this.lacunarity=t.lacunarity,this.diminish=t.diminish}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.position=this.position.toJSON(t).uuid,e.amplitude=this.amplitude.toJSON(t).uuid,e.octaves=this.octaves.toJSON(t).uuid,e.lacunarity=this.lacunarity.toJSON(t).uuid,e.diminish=this.diminish.toJSON(t).uuid),e}}Ut.prototype.nodeType="Fractal3D",Ut.Nodes=function(){const t=new D(Ct);return t.includes=[It.Nodes.noise3d],{fractal3d:t}}();class Mt extends C{constructor(t,e){super("v3"),this.value=t,this.scale=e||new B(1,1)}generate(t,e){if(t.isShader("fragment")){const n=t.include(Mt.Nodes.perturbNormal2Arb);this.normal=this.normal||new $,this.position=this.position||new Z(Z.VIEW),this.uv=this.uv||new G;let r=this.scale.build(t,"v2");return t.material.side===i.BackSide&&(r="-"+r),t.format(n+"( -"+this.position.build(t,"v3")+", "+this.normal.build(t,"v3")+", "+this.value.build(t,"v3")+", "+this.uv.build(t,"v2")+", "+r+" )",this.getType(t),e)}return console.warn("THREE.NormalMapNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}copy(t){return super.copy(t),this.value=t.value,this.scale=t.scale,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,e.scale=this.scale.toJSON(t).uuid),e}}Mt.Nodes={perturbNormal2Arb:new D("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = map * 2.0 - 1.0;\n\n\t\tmapN.xy *= normalScale;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n\t\t\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\n\n\t\t#else\n\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}",null,{derivatives:!0})},Mt.prototype.nodeType="NormalMap";class Dt extends C{constructor(t,e){super("v3"),this.value=t,this.scale=e||new j(1),this.toNormalMap=!1}generate(t,e){if(t.isShader("fragment")){if(this.toNormalMap){const n=t.include(Dt.Nodes.bumpToNormal);return t.format(n+"( "+this.value.build(t,"sampler2D")+", "+this.value.uv.build(t,"v2")+", "+this.scale.build(t,"f")+" )",this.getType(t),e)}{const n=t.include(Dt.Nodes.dHdxy_fwd),i=t.include(Dt.Nodes.perturbNormalArb);this.normal=this.normal||new $,this.position=this.position||new Z(Z.VIEW);const r=n+"( "+this.value.build(t,"sampler2D")+", "+this.value.uv.build(t,"v2")+", "+this.scale.build(t,"f")+" )";return t.format(i+"( -"+this.position.build(t,"v3")+", "+this.normal.build(t,"v3")+", "+r+" )",this.getType(t),e)}}return console.warn("THREE.BumpMapNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}copy(t){return super.copy(t),this.value=t.value,this.scale=t.scale,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,e.scale=this.scale.toJSON(t).uuid),e}}Dt.Nodes=function(){const t=new D("\n\n\t\tvec2 dHdxy_fwd( sampler2D bumpMap, vec2 vUv, float bumpScale ) {\n\n\t\t\tvec2 dSTdx = dFdx( vUv );\n\t\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\t\treturn vec2( dBx, dBy );\n\n\t\t}",null,{derivatives:!0});return{dHdxy_fwd:t,perturbNormalArb:new D("\n\n\t\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\t\tvec3 vN = surf_norm; // normalized\n\n\t\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\n\t\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t\t}",[t],{derivatives:!0}),bumpToNormal:new D("\n\t\tvec3 bumpToNormal( sampler2D bumpMap, vec2 uv, float scale ) {\n\n\t\t\tvec2 dSTdx = dFdx( uv );\n\t\t\tvec2 dSTdy = dFdy( uv );\n\n\t\t\tfloat Hll = texture2D( bumpMap, uv ).x;\n\t\t\tfloat dBx = texture2D( bumpMap, uv + dSTdx ).x - Hll;\n\t\t\tfloat dBy = texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n\t\t\treturn vec3( .5 - ( dBx * scale ), .5 - ( dBy * scale ), 1.0 );\n\n\t\t}",null,{derivatives:!0})}}(),Dt.prototype.nodeType="BumpMap",Dt.prototype.hashProperties=["toNormalMap"];(class extends R{constructor(t,e){super(),this.code=t,this.value=e}getType(t){return this.value?this.value.getType(t):t.isShader("fragment")?"f":"void"}generate(t,e){const n=this.code.build(t,e)+";";return t.addNodeCode(n),t.isShader("vertex")?this.value?this.value.build(t,e):void 0:this.value?this.value.build(t,e):t.format("0.0","f",e)}copy(t){return super.copy(t),this.code=t.code,this.value=t.value,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.code=this.code.toJSON(t).uuid,this.value&&(e.value=this.value.toJSON(t).uuid)),e}}).prototype.nodeType="Bypass";const Xt=E.elements;(class extends C{constructor(t,e,n,i){super("f"),this.x=t,this.y=e,this.z=n,this.w=i}getNumElements(){let t=Xt.length;for(;t--;)if(void 0!==this[Xt[t]]){++t;break}return Math.max(t,2)}getType(t){return t.getTypeFromLength(this.getNumElements())}generate(t,e){const n=this.getType(t),i=this.getNumElements(),r=[];for(let e=0;e<i;e++){const n=this[Xt[e]];r.push(n?n.build(t,"f"):"0.0")}const o=(i>1?t.getConstructorFromLength(i):"")+"( "+r.join(", ")+" )";return t.format(o,n,e)}copy(t){super.copy(t);for(const e in t.inputs)this[e]=t.inputs[e];return this}toJSON(t){let e=this.getJSONNode(t);if(!e){e=this.createJSONNode(t),e.inputs={};const n=this.getNumElements();for(let i=0;i<n;i++){const n=this[Xt[i]];n&&(e.inputs[Xt[i]]=n.toJSON(t).uuid)}}return e}}).prototype.nodeType="Join";class zt extends R{constructor(t,e){super(),this.node=t,this.components=e||"x"}getType(t){return t.getTypeFromLength(this.components.length)}generate(t,e){const n=this.node.getType(t),i=t.getTypeLength(n)-1;let r=this.node.build(t,n);if(i>0){let n=0;const o=t.colorToVectorProperties(this.components);let a;const s=o.length;for(a=0;a<s;a++)n=Math.max(n,t.getIndexByElement(o.charAt(a)));for(n>i&&(n=i),r+=".",a=0;a<s;a++){let e=t.getIndexByElement(o.charAt(a));e>n&&(e=n),r+=t.getElementByIndex(e)}return t.format(r,this.getType(t),e)}return t.format(r,n,e)}copy(t){return super.copy(t),this.node=t.node,this.components=t.components,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.node=this.node.toJSON(t).uuid,e.components=this.components),e}}zt.prototype.nodeType="Switch";const Yt="\nfloat remap( float value, float inLow, float inHigh, float outLow, float outHigh ) {\n\n\tfloat x = ( value - inLow ) / ( inHigh - inLow );\n\treturn outLow + ( outHigh - outLow ) * x;\n\n}\n\nvec2 remap( vec2 value, vec2 inLow, vec2 inHigh, vec2 outLow, vec2 outHigh ) {\n\n\treturn vec2(\n\t\tremap( value.x, inLow.x, inHigh.x, outLow.x, outHigh.x ),\n\t\tremap( value.y, inLow.y, inHigh.y, outLow.y, outHigh.y )\n\t);\n\n}\n\nvec2 remap( vec2 value, float inLow, float inHigh, float outLow, float outHigh ) {\n\n\treturn vec2(\n\t\tremap( value.x, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.y, inLow, inHigh, outLow, outHigh )\n\t);\n\n}\n\nvec3 remap( vec3 value, vec3 inLow, vec3 inHigh, vec3 outLow, vec3 outHigh ) {\n\n\treturn vec3(\n\t\tremap( value.x, inLow.x, inHigh.x, outLow.x, outHigh.x ),\n\t\tremap( value.y, inLow.y, inHigh.y, outLow.y, outHigh.y ),\n\t\tremap( value.z, inLow.z, inHigh.z, outLow.z, outHigh.z )\n\t);\n\n}\n\nvec3 remap( vec3 value, float inLow, float inHigh, float outLow, float outHigh ) {\n\n\treturn vec3(\n\t\tremap( value.x, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.y, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.z, inLow, inHigh, outLow, outHigh )\n\t);\n\n}\n\nvec4 remap( vec4 value, vec4 inLow, vec4 inHigh, vec4 outLow, vec4 outHigh ) {\n\n\treturn vec4(\n\t\tremap( value.x, inLow.x, inHigh.x, outLow.x, outHigh.x ),\n\t\tremap( value.y, inLow.y, inHigh.y, outLow.y, outHigh.y ),\n\t\tremap( value.z, inLow.z, inHigh.z, outLow.z, outHigh.z ),\n\t\tremap( value.w, inLow.w, inHigh.w, outLow.w, outHigh.w )\n\t);\n\n}\n\nvec4 remap( vec4 value, float inLow, float inHigh, float outLow, float outHigh ) {\n\n\treturn vec4(\n\t\tremap( value.x, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.y, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.z, inLow, inHigh, outLow, outHigh ),\n\t\tremap( value.w, inLow, inHigh, outLow, outHigh )\n\t);\n\n}\n".trim();class Jt extends C{constructor(t,e,n,i,r){super("f"),this.value=t,this.inLow=e,this.inHigh=n,this.outLow=i,this.outHigh=r}generate(t,e){const n=t.include(Jt.Nodes.remap);return t.format(n+"( "+[this.value.build(t),this.inLow.build(t),this.inHigh.build(t),this.outLow.build(t),this.outHigh.build(t)].join(", ")+" )",this.getType(t),e)}getType(t){return this.value.getType(t)}copy(t){super.copy(t),this.value=t.value,this.inLow=t.inLow,this.inHigh=t.inHigh,this.outLow=t.outLow,this.outHigh=t.outHigh}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,e.inLow=this.inLow.toJSON(t).uuid,e.inHigh=this.inHigh.toJSON(t).uuid,e.outLow=this.outLow.toJSON(t).uuid,e.outHigh=this.outHigh.toJSON(t).uuid),e}}Jt.prototype.nodeType="Remap",Jt.Nodes={remap:new D(Yt)};class kt extends j{constructor(t,e,n){super(),this.scale=void 0!==t?t:1,this.scope=e||kt.GLOBAL,this.timeScale=void 0!==n?n:void 0!==t}getReadonly(){return!1}getUnique(){return this.timeScale&&(this.scope===kt.GLOBAL||this.scope===kt.DELTA)}updateFrame(t){const e=this.timeScale?this.scale:1;switch(this.scope){case kt.LOCAL:this.value+=t.delta*e;break;case kt.DELTA:this.value=t.delta*e;break;default:this.value=t.time*e}}copy(t){return super.copy(t),this.scope=t.scope,this.scale=t.scale,this.timeScale=t.timeScale,this}toJSON(t){const e=super.toJSON(t);return e.scope=this.scope,e.scale=this.scale,e.timeScale=this.timeScale,e}}kt.GLOBAL="global",kt.LOCAL="local",kt.DELTA="delta",kt.prototype.nodeType="Timer",I.addKeyword("time",(function(){return new kt}));(class extends H{constructor(t,e){super(),this.params={},this.velocity=new i.Vector3,this.setTarget(t),this.setParams(e)}getReadonly(){return!1}setParams(t){if("elastic"===this.params.type)delete this.moment,delete this.speed,delete this.springVelocity,delete this.lastVelocity;if(this.params=t||{},"elastic"===this.params.type)this.moment=new i.Vector3,this.speed=new i.Vector3,this.springVelocity=new i.Vector3,this.lastVelocity=new i.Vector3}setTarget(t){this.target&&(delete this.position,delete this.oldPosition),this.target=t,t&&(this.position=t.getWorldPosition(this.position||new i.Vector3),this.oldPosition=this.position.clone())}updateFrameVelocity(){this.target&&(this.position=this.target.getWorldPosition(this.position||new i.Vector3),this.velocity.subVectors(this.position,this.oldPosition),this.oldPosition.copy(this.position))}updateFrame(t){if(this.updateFrameVelocity(t),"elastic"===this.params.type){const e=t.delta*(this.params.fps||60),n=Math.pow(this.params.spring,e),i=Math.pow(this.params.damping,e);this.velocity.multiplyScalar(Math.exp(-this.params.damping*e)),this.velocity.add(this.springVelocity),this.velocity.add(this.speed.multiplyScalar(i).multiplyScalar(1-n)),this.speed.subVectors(this.velocity,this.lastVelocity),this.springVelocity.add(this.speed),this.springVelocity.multiplyScalar(n),this.moment.add(this.springVelocity),this.moment.multiplyScalar(i),this.lastVelocity.copy(this.velocity),this.value.copy(this.moment)}else this.value.copy(this.velocity)}copy(t){return super.copy(t),t.target&&this.setTarget(t.target),this.setParams(t.params),this}toJSON(t){const e=super.toJSON(t);return this.target&&(e.target=this.target.uuid),e.params=JSON.parse(JSON.stringify(this.params)),e}}).prototype.nodeType="Velocity";(class extends q{constructor(t,e){super("( uvTransform * vec3( uvNode, 1 ) ).xy","vec2"),this.uv=t||new G,this.position=e||new yt}generate(t,e){return this.keywords.uvNode=this.uv,this.keywords.uvTransform=this.position,super.generate(t,e)}setUvTransform(t,e,n,i,r,o,a){o=void 0!==o?o:.5,a=void 0!==a?a:.5,this.position.value.setUvTransform(t,e,n,i,r,o,a)}copy(t){return super.copy(t),this.uv=t.uv,this.position=t.position,this}toJSON(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).uv=this.uv.toJSON(t).uuid,e.position=this.position.toJSON(t).uuid),e}}).prototype.nodeType="UVTransform";class Qt extends j{constructor(t){super(),this.texture=t,this.maxMIPLevel=0}get value(){if(0===this.maxMIPLevel){var t=this.texture.value.image;Array.isArray(t)&&(t=t[0]),this.maxMIPLevel=void 0!==t?Math.log(Math.max(t.width,t.height))*Math.LOG2E:0}return this.maxMIPLevel}set value(t){}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.texture=this.texture.uuid),e}}Qt.prototype.nodeType="MaxMIPLevel";class Bt extends C{constructor(t,e){super("f"),this.roughness=t,this.texture=e,this.maxMIPLevel=void 0}setTexture(t){return this.texture=t,this}generate(t,e){if(t.isShader("fragment")){this.maxMIPLevel=this.maxMIPLevel||new Qt,this.maxMIPLevel.texture=this.texture;const n=t.include(Bt.Nodes.getSpecularMIPLevel);return t.format(n+"( "+this.roughness.build(t,"f")+", "+this.maxMIPLevel.build(t,"f")+" )",this.type,e)}return console.warn("THREE.SpecularMIPLevelNode is not compatible with "+t.shader+" shader."),t.format("0.0",this.type,e)}copy(t){return super.copy(t),this.texture=t.texture,this.roughness=t.roughness,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.texture=this.texture,e.roughness=this.roughness),e}}Bt.Nodes={getSpecularMIPLevel:new D("\n\n\t\tfloat getSpecularMIPLevel( const in float roughness, const in float maxMIPLevelScalar ) {\n\n\t\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n\t\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t\t}")},Bt.prototype.nodeType="SpecularMIPLevel";(class extends C{constructor(t){super(),this.slots=t||{}}getType(t,e){return e}generate(t,e){return this.slots[t.slot]?this.slots[t.slot].build(t,e):t.format("0.0","f",e)}copy(t){super.copy(t);for(const e in t.slots)this.slots[e]=t.slots[e];return this}toJSON(t){let e=this.getJSONNode(t);if(!e){e=this.createJSONNode(t),e.slots={};for(const n in this.slots){const i=this.slots[n];i&&(e.slots[n]=i.toJSON(t).uuid)}}return e}}).prototype.nodeType="SubSlot";class Ht extends C{constructor(t,e,n,i){super("v4"),this.value=t,this.uv=e||new G,this.radius=n||new B(1,1),this.size=i,this.blurX=!0,this.blurY=!0,this.horizontal=new j(1/64),this.vertical=new j(1/64)}updateFrame(){if(this.size)this.horizontal.value=this.radius.x/this.size.x,this.vertical.value=this.radius.y/this.size.y;else if(this.value.value&&this.value.value.image){const t=this.value.value.image;this.horizontal.value=this.radius.x/t.width,this.vertical.value=this.radius.y/t.height}}generate(t,e){if(t.isShader("fragment")){const n=[];let i;const r=t.include(Ht.Nodes.blurX),o=t.include(Ht.Nodes.blurY);return this.blurX&&n.push(r+"( "+this.value.build(t,"sampler2D")+", "+this.uv.build(t,"v2")+", "+this.horizontal.build(t,"f")+" )"),this.blurY&&n.push(o+"( "+this.value.build(t,"sampler2D")+", "+this.uv.build(t,"v2")+", "+this.vertical.build(t,"f")+" )"),i=2==n.length?"( "+n.join(" + ")+" / 2.0 )":n.length?"( "+n[0]+" )":"vec4( 0.0 )",t.format(i,this.getType(t),e)}return console.warn("THREE.BlurNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)}copy(t){return super.copy(t),this.value=t.value,this.uv=t.uv,this.radius=t.radius,void 0!==t.size&&(this.size=new i.Vector2(t.size.x,t.size.y)),this.blurX=t.blurX,this.blurY=t.blurY,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.value=this.value.toJSON(t).uuid,e.uv=this.uv.toJSON(t).uuid,e.radius=this.radius.toJSON(t).uuid,this.size&&(e.size={x:this.size.x,y:this.size.y}),e.blurX=this.blurX,e.blurY=this.blurY),e}}Ht.Nodes={blurX:new D("\n\t\tvec4 blurX( sampler2D tex, vec2 uv, float s ) {\n\t\t\tvec4 sum = vec4( 0.0 );\n\t\t\tsum += texture2D( tex, vec2( uv.x - 4.0 * s, uv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tex, vec2( uv.x - 3.0 * s, uv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tex, vec2( uv.x - 2.0 * s, uv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tex, vec2( uv.x - 1.0 * s, uv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tex, vec2( uv.x + 1.0 * s, uv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tex, vec2( uv.x + 2.0 * s, uv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tex, vec2( uv.x + 3.0 * s, uv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tex, vec2( uv.x + 4.0 * s, uv.y ) ) * 0.051;\n\t\t\treturn sum * .667;\n\t\t}"),blurY:new D("\n\t\tvec4 blurY( sampler2D tex, vec2 uv, float s ) {\n\t\t\tvec4 sum = vec4( 0.0 );\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y - 4.0 * s ) ) * 0.051;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y - 3.0 * s ) ) * 0.0918;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y - 2.0 * s ) ) * 0.12245;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y - 1.0 * s ) ) * 0.1531;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y + 1.0 * s ) ) * 0.1531;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y + 2.0 * s ) ) * 0.12245;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y + 3.0 * s ) ) * 0.0918;\n\t\t\tsum += texture2D( tex, vec2( uv.x, uv.y + 4.0 * s ) ) * 0.051;\n\t\t\treturn sum * .667;\n\t\t}")},Ht.prototype.nodeType="Blur",Ht.prototype.hashProperties=["blurX","blurY"];class Vt extends C{constructor(t){super("f"),this.rgb=t}generate(t,e){const n=t.include(Vt.Nodes.luminance);return t.format(n+"( "+this.rgb.build(t,"v3")+" )",this.getType(t),e)}copy(t){return super.copy(t),this.rgb=t.rgb,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.rgb=this.rgb.toJSON(t).uuid),e}}Vt.Nodes=function(){const t=new z("vec3 LUMA vec3( 0.2125, 0.7154, 0.0721 )");return{LUMA:t,luminance:new D("\n\n\t\tfloat luminance( vec3 rgb ) {\n\n\t\t\treturn dot( rgb, LUMA );\n\n\t\t}",[t])}}(),Vt.prototype.nodeType="Luminance";class Gt extends C{constructor(t,e,n){super("v3"),this.rgb=t,this.adjustment=e,this.method=n||Gt.SATURATION}generate(t,e){const n=this.rgb.build(t,"v3"),i=this.adjustment.build(t,"f");switch(this.method){case Gt.BRIGHTNESS:return t.format("( "+n+" + "+i+" )",this.getType(t),e);case Gt.CONTRAST:return t.format("( "+n+" * "+i+" )",this.getType(t),e)}const r=t.include(Gt.Nodes[this.method]);return t.format(r+"( "+n+", "+i+" )",this.getType(t),e)}copy(t){return super.copy(t),this.rgb=t.rgb,this.adjustment=t.adjustment,this.method=t.method,this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.rgb=this.rgb.toJSON(t).uuid,e.adjustment=this.adjustment.toJSON(t).uuid,e.method=this.method),e}}Gt.Nodes={hue:new D("\n\t\tvec3 hue(vec3 rgb, float adjustment) {\n\n\t\t\tconst mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\n\t\t\tconst mat3 YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\n\n\t\t\tvec3 yiq = RGBtoYIQ * rgb;\n\n\t\t\tfloat hue = atan(yiq.z, yiq.y) + adjustment;\n\t\t\tfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n\n\t\t\treturn YIQtoRGB * vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n\n\t\t}"),saturation:new D("\n\t\tvec3 saturation(vec3 rgb, float adjustment) {\n\n\t\t\tvec3 intensity = vec3( luminance( rgb ) );\n\n\t\t\treturn mix( intensity, rgb, adjustment );\n\n\t\t}",[Vt.Nodes.luminance]),vibrance:new D("\n\n\t\tvec3 vibrance(vec3 rgb, float adjustment) {\n\n\t\t\tfloat average = (rgb.r + rgb.g + rgb.b) / 3.0;\n\n\t\t\tfloat mx = max(rgb.r, max(rgb.g, rgb.b));\n\t\t\tfloat amt = (mx - average) * (-3.0 * adjustment);\n\n\t\t\treturn mix(rgb.rgb, vec3(mx), amt);\n\n\t\t}")},Gt.SATURATION="saturation",Gt.HUE="hue",Gt.VIBRANCE="vibrance",Gt.BRIGHTNESS="brightness",Gt.CONTRAST="contrast",Gt.prototype.nodeType="ColorAdjustment",Gt.prototype.hashProperties=["method"];class jt extends R{constructor(){super(),this.color=new ft(16777215)}generate(t){let e;if(t.isShader("vertex")){const n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0,i=["#include <beginnormal_vertex>","#include <morphnormal_vertex>","#include <skinnormal_vertex>","#include <defaultnormal_vertex>"];i.push("#include <begin_vertex>"),n&&i.push(n.code,n.result?"transformed = "+n.result+";":""),i.push("#include <morphtarget_vertex>","#include <skinning_vertex>","#include <project_vertex>","#include <logdepthbuf_vertex>","#include <worldpos_vertex>","#include <clipping_planes_vertex>","#include <fog_vertex>"),e=i.join("\n")}else{this.color.analyze(t,{slot:"color"}),this.alpha&&this.alpha.analyze(t),this.mask&&this.mask.analyze(t);const n=this.color.flow(t,"c",{slot:"color"}),i=this.alpha?this.alpha.flow(t,"f"):void 0,r=this.mask?this.mask.flow(t,"b"):void 0;t.requires.transparent=void 0!==i;const o=[n.code];r&&o.push(r.code,"if ( ! "+r.result+" ) discard;"),i&&o.push(i.code,"#ifdef ALPHATEST"," if ( "+i.result+" <= ALPHATEST ) discard;","#endif"),i?o.push("gl_FragColor = vec4("+n.result+", "+i.result+" );"):o.push("gl_FragColor = vec4("+n.result+", 1.0 );"),e=o.join("\n")}return e}copy(t){return super.copy(t),this.color=t.color,t.position&&(this.position=t.position),t.alpha&&(this.alpha=t.alpha),t.mask&&(this.mask=t.mask),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),e.color=this.color.toJSON(t).uuid,this.position&&(e.position=this.position.toJSON(t).uuid),this.alpha&&(e.alpha=this.alpha.toJSON(t).uuid),this.mask&&(e.mask=this.mask.toJSON(t).uuid)),e}}jt.prototype.nodeType="Basic";class qt extends R{constructor(){super(),this.color=new ft(15658734),this.spherical=!0}build(t){let e;if(t.define("SPRITE"),t.requires.lights=!1,t.requires.transparent=void 0!==this.alpha,t.isShader("vertex")){const n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform(i.UniformsUtils.merge([i.UniformsLib.fog])),t.addParsCode("\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>"),e=["#include <clipping_planes_fragment>","#include <begin_vertex>"],n&&e.push(n.code,n.result?"transformed = "+n.result+";":""),e.push("#include <project_vertex>","#include <fog_vertex>","mat4 modelViewMtx = modelViewMatrix;","mat4 modelMtx = modelMatrix;","modelMtx[3][0] = 0.0;","modelMtx[3][1] = 0.0;","modelMtx[3][2] = 0.0;"),this.spherical||e.push("modelMtx[1][1] = 1.0;"),e.push("modelViewMtx[0][0] = 1.0;","modelViewMtx[0][1] = 0.0;","modelViewMtx[0][2] = 0.0;"),this.spherical&&e.push("modelViewMtx[1][0] = 0.0;","modelViewMtx[1][1] = 1.0;","modelViewMtx[1][2] = 0.0;"),e.push("modelViewMtx[2][0] = 0.0;","modelViewMtx[2][1] = 0.0;","modelViewMtx[2][2] = 1.0;","gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","#include <fog_vertex>")}else{t.addParsCode("\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>"),t.addCode("\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\t#include <logdepthbuf_fragment>"),this.mask&&this.mask.analyze(t),this.alpha&&this.alpha.analyze(t),this.color.analyze(t,{slot:"color"});const n=this.mask?this.mask.flow(t,"b"):void 0,i=this.alpha?this.alpha.flow(t,"f"):void 0,r=this.color.flow(t,"c",{slot:"color"});e=[],n&&e.push(n.code,"if ( ! "+n.result+" ) discard;"),i?e.push(i.code,"#ifdef ALPHATEST","if ( "+i.result+" <= ALPHATEST ) discard;","#endif",r.code,"gl_FragColor = vec4( "+r.result+", "+i.result+" );"):e.push(r.code,"gl_FragColor = vec4( "+r.result+", 1.0 );"),e.push("#include <tonemapping_fragment>","#include <encodings_fragment>","#include <fog_fragment>")}return e.join("\n")}copy(t){return super.copy(t),t.position&&(this.position=t.position),this.color=t.color,void 0!==t.spherical&&(this.spherical=t.spherical),t.mask&&(this.mask=t.mask),t.alpha&&(this.alpha=t.alpha),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),this.position&&(e.position=this.position.toJSON(t).uuid),e.color=this.color.toJSON(t).uuid,!1===this.spherical&&(e.spherical=!1),this.mask&&(e.mask=this.mask.toJSON(t).uuid),this.alpha&&(e.alpha=this.alpha.toJSON(t).uuid)),e}}qt.prototype.nodeType="Sprite";class Wt extends R{constructor(){super(),this.color=new ft(15658734),this.specular=new ft(1118481),this.shininess=new j(30)}build(t){let e;if(t.define("PHONG"),t.requires.lights=!0,t.isShader("vertex")){const n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform(i.UniformsUtils.merge([i.UniformsLib.fog,i.UniformsLib.lights])),t.addParsCode('\n\t\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t\t//"#include <encodings_pars_fragment> // encoding functions\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <normal_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>');const r=["#include <beginnormal_vertex>","#include <morphnormal_vertex>","#include <skinbase_vertex>","#include <skinnormal_vertex>","#include <defaultnormal_vertex>","#include <normal_vertex>","#include <begin_vertex>"];n&&r.push(n.code,n.result?"transformed = "+n.result+";":""),r.push("\t#include <morphtarget_vertex>","\t#include <skinning_vertex>","\t#include <project_vertex>","\t#include <fog_vertex>","\t#include <logdepthbuf_vertex>","\t#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","\t#include <worldpos_vertex>","\t#include <shadowmap_vertex>","\t#include <fog_vertex>"),e=r.join("\n")}else{this.mask&&this.mask.analyze(t),this.color.analyze(t,{slot:"color"}),this.specular.analyze(t),this.shininess.analyze(t),this.alpha&&this.alpha.analyze(t),this.normal&&this.normal.analyze(t),this.light&&this.light.analyze(t,{cache:"light"}),this.ao&&this.ao.analyze(t),this.ambient&&this.ambient.analyze(t),this.shadow&&this.shadow.analyze(t),this.emissive&&this.emissive.analyze(t,{slot:"emissive"}),this.environment&&this.environment.analyze(t,{slot:"environment"}),this.environmentAlpha&&this.environment&&this.environmentAlpha.analyze(t);const n=this.mask?this.mask.flow(t,"b"):void 0,i=this.color.flow(t,"c",{slot:"color"}),r=this.specular.flow(t,"c"),o=this.shininess.flow(t,"f"),a=this.alpha?this.alpha.flow(t,"f"):void 0,s=this.normal?this.normal.flow(t,"v3"):void 0,u=this.light?this.light.flow(t,"v3",{cache:"light"}):void 0,l=this.ao?this.ao.flow(t,"f"):void 0,d=this.ambient?this.ambient.flow(t,"c"):void 0,c=this.shadow?this.shadow.flow(t,"c"):void 0,h=this.emissive?this.emissive.flow(t,"c",{slot:"emissive"}):void 0,f=this.environment?this.environment.flow(t,"c",{slot:"environment"}):void 0,p=this.environmentAlpha&&this.environment?this.environmentAlpha.flow(t,"f"):void 0;t.requires.transparent=void 0!==a,t.addParsCode("\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <normal_pars_fragment>\n\t\t\t\t#include <lights_phong_pars_fragment>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>");const m=["#include <normal_fragment_begin>","\tBlinnPhongMaterial material;"];n&&m.push(n.code,"if ( ! "+n.result+" ) discard;"),m.push(i.code,"\tvec3 diffuseColor = "+i.result+";","\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","#include <logdepthbuf_fragment>",r.code,"\tvec3 specular = "+r.result+";",o.code,"\tfloat shininess = max( 0.0001, "+o.result+" );","\tfloat specularStrength = 1.0;"),a&&m.push(a.code,"#ifdef ALPHATEST","if ( "+a.result+" <= ALPHATEST ) discard;","#endif"),s&&m.push(s.code,"normal = "+s.result+";"),m.push("material.diffuseColor = "+(u?"vec3( 1.0 )":"diffuseColor")+";"),m.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),u&&(m.push(u.code,"reflectedLight.directDiffuse = "+u.result+";"),m.push("reflectedLight.directDiffuse *= diffuseColor;","reflectedLight.indirectDiffuse *= diffuseColor;")),l&&m.push(l.code,"reflectedLight.indirectDiffuse *= "+l.result+";"),d&&m.push(d.code,"reflectedLight.indirectDiffuse += "+d.result+";"),c&&m.push(c.code,"reflectedLight.directDiffuse *= "+c.result+";","reflectedLight.directSpecular *= "+c.result+";"),h&&m.push(h.code,"reflectedLight.directDiffuse += "+h.result+";"),m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"),f&&(m.push(f.code),p?m.push(p.code,"outgoingLight = mix( outgoingLight, "+f.result+", "+p.result+" );"):m.push("outgoingLight = "+f.result+";")),a?m.push("gl_FragColor = vec4( outgoingLight, "+a.result+" );"):m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),m.push("#include <tonemapping_fragment>","#include <encodings_fragment>","#include <fog_fragment>","#include <premultiplied_alpha_fragment>"),e=m.join("\n")}return e}copy(t){return super.copy(t),t.position&&(this.position=t.position),this.color=t.color,this.specular=t.specular,this.shininess=t.shininess,t.mask&&(this.mask=t.mask),t.alpha&&(this.alpha=t.alpha),t.normal&&(this.normal=t.normal),t.light&&(this.light=t.light),t.shadow&&(this.shadow=t.shadow),t.ao&&(this.ao=t.ao),t.emissive&&(this.emissive=t.emissive),t.ambient&&(this.ambient=t.ambient),t.environment&&(this.environment=t.environment),t.environmentAlpha&&(this.environmentAlpha=t.environmentAlpha),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),this.position&&(e.position=this.position.toJSON(t).uuid),e.color=this.color.toJSON(t).uuid,e.specular=this.specular.toJSON(t).uuid,e.shininess=this.shininess.toJSON(t).uuid,this.mask&&(e.mask=this.mask.toJSON(t).uuid),this.alpha&&(e.alpha=this.alpha.toJSON(t).uuid),this.normal&&(e.normal=this.normal.toJSON(t).uuid),this.light&&(e.light=this.light.toJSON(t).uuid),this.ao&&(e.ao=this.ao.toJSON(t).uuid),this.ambient&&(e.ambient=this.ambient.toJSON(t).uuid),this.shadow&&(e.shadow=this.shadow.toJSON(t).uuid),this.emissive&&(e.emissive=this.emissive.toJSON(t).uuid),this.environment&&(e.environment=this.environment.toJSON(t).uuid),this.environmentAlpha&&(e.environmentAlpha=this.environmentAlpha.toJSON(t).uuid)),e}}Wt.prototype.nodeType="Phong";class Kt extends R{constructor(){super(),this.color=new ft(16777215),this.roughness=new j(1),this.metalness=new j(0)}build(t){let e;t.define("STANDARD");const n=this.clearcoat||this.clearcoatRoughness||this.clearCoatNormal;if(n&&t.define("CLEARCOAT"),t.requires.lights=!0,t.extensions.derivatives=!0,t.extensions.shaderTextureLOD=!0,t.isShader("vertex")){const n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform(i.UniformsUtils.merge([i.UniformsLib.fog,i.UniformsLib.lights])),i.UniformsLib.LTC_1&&(t.uniforms.ltc_1={value:void 0},t.uniforms.ltc_2={value:void 0}),t.addParsCode('\n\t\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t\t#ifndef FLAT_SHADED\n\n\t\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\t#endif\n\n\t\t\t\t//"#include <encodings_pars_fragment> // encoding functions\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>');const r=["#include <beginnormal_vertex>","#include <morphnormal_vertex>","#include <skinbase_vertex>","#include <skinnormal_vertex>","#include <defaultnormal_vertex>","#ifndef FLAT_SHADED","\tvNormal = normalize( transformedNormal );","#endif","#include <begin_vertex>"];n&&r.push(n.code,n.result?"transformed = "+n.result+";":""),r.push("#include <morphtarget_vertex>","#include <skinning_vertex>","#include <project_vertex>","#include <fog_vertex>","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>","#include <shadowmap_vertex>"),e=r.join("\n")}else{const i=new q("material.roughness","f"),r=new q("material.clearcoatRoughness","f"),o={roughness:i,bias:new Bt(i),viewNormal:new q("normal","v3"),worldNormal:new q("inverseTransformDirection( geometry.normal, viewMatrix )","v3"),gamma:!0},a={gamma:!0},s={roughness:r,bias:new Bt(r),viewNormal:new q("clearcoatNormal","v3"),worldNormal:new q("inverseTransformDirection( geometry.clearcoatNormal, viewMatrix )","v3"),gamma:!0};this.mask&&this.mask.analyze(t),this.color.analyze(t,{slot:"color",context:a}),this.roughness.analyze(t),this.metalness.analyze(t),this.alpha&&this.alpha.analyze(t),this.normal&&this.normal.analyze(t),this.clearcoat&&this.clearcoat.analyze(t),this.clearcoatRoughness&&this.clearcoatRoughness.analyze(t),this.clearcoatNormal&&this.clearcoatNormal.analyze(t),this.reflectivity&&this.reflectivity.analyze(t),this.light&&this.light.analyze(t,{cache:"light"}),this.ao&&this.ao.analyze(t),this.ambient&&this.ambient.analyze(t),this.shadow&&this.shadow.analyze(t),this.emissive&&this.emissive.analyze(t,{slot:"emissive"}),this.environment&&(this.environment.analyze(t,{cache:"radiance",context:o,slot:"radiance"}),t.requires.irradiance&&this.environment.analyze(t,{cache:"irradiance",context:o,slot:"irradiance"})),this.sheenTint&&this.sheenTint.analyze(t);const u=this.mask?this.mask.flow(t,"b"):void 0,l=this.color.flow(t,"c",{slot:"color",context:a}),d=this.roughness.flow(t,"f"),c=this.metalness.flow(t,"f"),h=this.alpha?this.alpha.flow(t,"f"):void 0,f=this.normal?this.normal.flow(t,"v3"):void 0,p=this.clearcoat?this.clearcoat.flow(t,"f"):void 0,m=this.clearcoatRoughness?this.clearcoatRoughness.flow(t,"f"):void 0,g=this.clearcoatNormal?this.clearcoatNormal.flow(t,"v3"):void 0,v=this.reflectivity?this.reflectivity.flow(t,"f"):void 0,x=this.light?this.light.flow(t,"v3",{cache:"light"}):void 0,y=this.ao?this.ao.flow(t,"f"):void 0,A=this.ambient?this.ambient.flow(t,"c"):void 0,b=this.shadow?this.shadow.flow(t,"c"):void 0,_=this.emissive?this.emissive.flow(t,"c",{slot:"emissive"}):void 0;let N;this.environment&&(N={radiance:this.environment.flow(t,"c",{cache:"radiance",context:o,slot:"radiance"})},t.requires.irradiance&&(N.irradiance=this.environment.flow(t,"c",{cache:"irradiance",context:o,slot:"irradiance"})));const T=n&&N?this.environment.flow(t,"c",{cache:"clearcoat",context:s,slot:"environment"}):void 0,F=this.sheenTint?this.sheenTint.flow(t,"c"):void 0;t.requires.transparent=void 0!==h,t.addParsCode("\n\t\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t\t#define NODE_MAXIMUM_SPECULAR_COEFFICIENT 0.16\n\t\t\t\t#define NODE_DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n\t\t\t\t#ifndef FLAT_SHADED\n\n\t\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <dithering_pars_fragment>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <lights_physical_pars_fragment>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>");const S=["#include <clipping_planes_fragment>","\t#include <normal_fragment_begin>","\t#include <clearcoat_normal_fragment_begin>","\tPhysicalMaterial material;","\tmaterial.diffuseColor = vec3( 1.0 );"];u&&S.push(u.code,"if ( ! "+u.result+" ) discard;"),S.push(l.code,"\tvec3 diffuseColor = "+l.result+";","\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","#include <logdepthbuf_fragment>",d.code,"\tfloat roughnessFactor = "+d.result+";",c.code,"\tfloat metalnessFactor = "+c.result+";"),h&&S.push(h.code,"#ifdef ALPHATEST","\tif ( "+h.result+" <= ALPHATEST ) discard;","#endif"),f&&S.push(f.code,"normal = "+f.result+";"),g&&S.push(g.code,"clearcoatNormal = "+g.result+";"),S.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"),S.push("material.diffuseColor = "+(x?"vec3( 1.0 )":"diffuseColor * ( 1.0 - metalnessFactor )")+";","material.roughness = max( roughnessFactor, 0.0525 );","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"),p?S.push(p.code,"material.clearcoat = saturate( "+p.result+" );"):n&&S.push("material.clearcoat = 0.0;"),m?S.push(m.code,"material.clearcoatRoughness = max( "+m.result+", 0.0525 );","material.clearcoatRoughness += geometryRoughness;","material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );"):n&&S.push("material.clearcoatRoughness = 0.0;"),F&&S.push("material.sheenTint = "+F.result+";"),v?S.push(v.code,"material.specularColor = mix( vec3( NODE_MAXIMUM_SPECULAR_COEFFICIENT * pow2( "+v.result+" ) ), diffuseColor, metalnessFactor );"):S.push("material.specularColor = mix( vec3( NODE_DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor, metalnessFactor );"),S.push("#include <lights_fragment_begin>"),x&&(S.push(x.code,"reflectedLight.directDiffuse = "+x.result+";"),S.push("diffuseColor *= 1.0 - metalnessFactor;","reflectedLight.directDiffuse *= diffuseColor;","reflectedLight.indirectDiffuse *= diffuseColor;")),y&&S.push(y.code,"reflectedLight.indirectDiffuse *= "+y.result+";","float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );","reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, "+y.result+", material.roughness );"),A&&S.push(A.code,"reflectedLight.indirectDiffuse += "+A.result+";"),b&&S.push(b.code,"reflectedLight.directDiffuse *= "+b.result+";","reflectedLight.directSpecular *= "+b.result+";"),_&&S.push(_.code,"reflectedLight.directDiffuse += "+_.result+";"),N&&(S.push(N.radiance.code),t.requires.irradiance&&S.push(N.irradiance.code),T&&S.push(T.code,"clearcoatRadiance += "+T.result+";"),S.push("radiance += "+N.radiance.result+";"),t.requires.irradiance&&S.push("iblIrradiance += PI * "+N.irradiance.result+";")),S.push("#include <lights_fragment_end>"),S.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"),h?S.push("gl_FragColor = vec4( outgoingLight, "+h.result+" );"):S.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),S.push("#include <tonemapping_fragment>","#include <encodings_fragment>","#include <fog_fragment>","#include <premultiplied_alpha_fragment>","#include <dithering_fragment>"),e=S.join("\n")}return e}copy(t){return super.copy(t),t.position&&(this.position=t.position),this.color=t.color,this.roughness=t.roughness,this.metalness=t.metalness,t.mask&&(this.mask=t.mask),t.alpha&&(this.alpha=t.alpha),t.normal&&(this.normal=t.normal),t.clearcoat&&(this.clearcoat=t.clearcoat),t.clearcoatRoughness&&(this.clearcoatRoughness=t.clearcoatRoughness),t.clearcoatNormal&&(this.clearcoatNormal=t.clearcoatNormal),t.reflectivity&&(this.reflectivity=t.reflectivity),t.light&&(this.light=t.light),t.shadow&&(this.shadow=t.shadow),t.ao&&(this.ao=t.ao),t.emissive&&(this.emissive=t.emissive),t.ambient&&(this.ambient=t.ambient),t.environment&&(this.environment=t.environment),t.sheenTint&&(this.sheenTint=t.sheenTint),this}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),this.position&&(e.position=this.position.toJSON(t).uuid),e.color=this.color.toJSON(t).uuid,e.roughness=this.roughness.toJSON(t).uuid,e.metalness=this.metalness.toJSON(t).uuid,this.mask&&(e.mask=this.mask.toJSON(t).uuid),this.alpha&&(e.alpha=this.alpha.toJSON(t).uuid),this.normal&&(e.normal=this.normal.toJSON(t).uuid),this.clearcoat&&(e.clearcoat=this.clearcoat.toJSON(t).uuid),this.clearcoatRoughness&&(e.clearcoatRoughness=this.clearcoatRoughness.toJSON(t).uuid),this.clearcoatNormal&&(e.clearcoatNormal=this.clearcoatNormal.toJSON(t).uuid),this.reflectivity&&(e.reflectivity=this.reflectivity.toJSON(t).uuid),this.light&&(e.light=this.light.toJSON(t).uuid),this.shadow&&(e.shadow=this.shadow.toJSON(t).uuid),this.ao&&(e.ao=this.ao.toJSON(t).uuid),this.emissive&&(e.emissive=this.emissive.toJSON(t).uuid),this.ambient&&(e.ambient=this.ambient.toJSON(t).uuid),this.environment&&(e.environment=this.environment.toJSON(t).uuid),this.sheenTint&&(e.sheenTint=this.sheenTint.toJSON(t).uuid)),e}}Kt.prototype.nodeType="Standard";class Zt extends Kt{constructor(){super(),this.properties={color:new i.Color(16777215),roughness:.5,metalness:.5,normalScale:new i.Vector2(1,1)},this.inputs={color:new bt(this.properties,"color","c"),roughness:new bt(this.properties,"roughness","f"),metalness:new bt(this.properties,"metalness","f"),normalScale:new bt(this.properties,"normalScale","v2")}}build(t){const e=this.properties,n=this.inputs;if(t.isShader("fragment")){const i=t.findNode(e.color,n.color),r=t.resolve(e.map);this.color=r?new it(i,r,it.MUL):i;const o=t.findNode(e.roughness,n.roughness),a=t.resolve(e.roughnessMap);this.roughness=a?new it(o,new zt(a,"g"),it.MUL):o;const s=t.findNode(e.metalness,n.metalness),u=t.resolve(e.metalnessMap);this.metalness=u?new it(s,new zt(u,"b"),it.MUL):s,e.normalMap?(this.normal=new Mt(t.resolve(e.normalMap)),this.normal.scale=t.findNode(e.normalScale,n.normalScale)):this.normal=void 0,this.environment=t.resolve(e.envMap)}return super.build(t)}toJSON(t){let e=this.getJSONNode(t);return e||(e=this.createJSONNode(t),console.warn(".toJSON not implemented in",this)),e}}Zt.prototype.nodeType="MeshStandard";E.addShortcuts(class extends mt{constructor(){const t=new jt;super(t,t),this.type="BasicNodeMaterial"}}.prototype,"fragment",["color","alpha","mask","position"]);E.addShortcuts(class extends mt{constructor(){const t=new qt;super(t,t),this.type="SpriteNodeMaterial"}}.prototype,"fragment",["color","alpha","mask","position","spherical"]);E.addShortcuts(class extends mt{constructor(){const t=new Wt;super(t,t),this.type="PhongNodeMaterial"}}.prototype,"fragment",["color","alpha","specular","shininess","normal","emissive","ambient","light","shadow","ao","environment","environmentAlpha","mask","position"]);E.addShortcuts(class extends mt{constructor(){const t=new Kt;super(t,t),this.type="StandardNodeMaterial"}}.prototype,"fragment",["color","alpha","roughness","metalness","reflectivity","clearcoat","clearcoatRoughness","clearcoatNormal","normal","emissive","ambient","light","shadow","ao","environment","mask","position","sheenTint"]);E.addShortcuts(class extends mt{constructor(){const t=new Zt;super(t,t),this.type="MeshStandardNodeMaterial"}}.prototype,"properties",["color","roughness","metalness","map","normalMap","normalScale","metalnessMap","roughnessMap","envMap"]);function $t(t){return $t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$t(t)}function te(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ee(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function ne(t,e){return ne=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},ne(t,e)}function ie(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=oe(t);if(e){var r=oe(this).constructor;n=Reflect.construct(i,arguments,r)}else n=i.apply(this,arguments);return re(this,n)}}function re(t,e){if(e&&("object"===$t(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function oe(t){return oe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},oe(t)}var ae=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ne(t,e)}(o,t);var e,n,i,r=ie(o);function o(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.hue,i=void 0===n?0:n,a=e.saturation,s=void 0===a?1:a,u=e.vibrance,l=void 0===u?0:u,d=e.brightness,c=void 0===d?0:d,h=e.contrast,f=void 0===h?1:h;te(this,o),t=r.call(this),i=new j(i),s=new j(s),l=new j(l),c=new j(c),f=new j(f);var p=new gt,m=new Gt(p,i,Gt.HUE),g=new Gt(m,s,Gt.SATURATION),v=new Gt(g,l,Gt.VIBRANCE),x=new Gt(v,c,Gt.BRIGHTNESS),y=new Gt(x,f,Gt.CONTRAST);return t.input=y,t._hue=i,t._saturation=s,t._vibrance=l,t._brightness=c,t._contrast=f,t}return e=o,(n=[{key:"brightness",get:function(){return this._brightness.value},set:function(t){this._brightness.value=t}},{key:"contrast",get:function(){return this._contrast.value},set:function(t){this._contrast.value=t}},{key:"hue",get:function(){return this._hue.value},set:function(t){this._hue.value=t}},{key:"saturation",get:function(){return this._saturation.value},set:function(t){this._saturation.value=t}},{key:"vibrance",get:function(){return this._vibrance.value},set:function(t){this._vibrance.value=t}}])&&ee(e.prototype,n),i&&ee(e,i),o}(vt);const se={uniforms:{tDiffuse:{value:null},resolution:{value:new i.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:'\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\t#define FXAA_PC 1\n\t\t#define FXAA_GLSL_100 1\n\t\t#define FXAA_QUALITY_PRESET 12\n\n\t\t#define FXAA_GREEN_AS_LUMA 1\n\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_PC_CONSOLE\n\t\t\t\t//\n\t\t\t\t// The console algorithm for PC is included\n\t\t\t\t// for developers targeting really low spec machines.\n\t\t\t\t// Likely better to just run FXAA_PC, and use a really low preset.\n\t\t\t\t//\n\t\t\t\t#define FXAA_PC_CONSOLE 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_120\n\t\t\t\t#define FXAA_GLSL_120 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_130\n\t\t\t\t#define FXAA_GLSL_130 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_3\n\t\t\t\t#define FXAA_HLSL_3 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_4\n\t\t\t\t#define FXAA_HLSL_4 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_5\n\t\t\t\t#define FXAA_HLSL_5 0\n\t\t#endif\n\t\t/*==========================================================================*/\n\t\t#ifndef FXAA_GREEN_AS_LUMA\n\t\t\t\t//\n\t\t\t\t// For those using non-linear color,\n\t\t\t\t// and either not able to get luma in alpha, or not wanting to,\n\t\t\t\t// this enables FXAA to run using green as a proxy for luma.\n\t\t\t\t// So with this enabled, no need to pack luma in alpha.\n\t\t\t\t//\n\t\t\t\t// This will turn off AA on anything which lacks some amount of green.\n\t\t\t\t// Pure red and blue or combination of only R and B, will get no AA.\n\t\t\t\t//\n\t\t\t\t// Might want to lower the settings for both,\n\t\t\t\t//\t\tfxaaConsoleEdgeThresholdMin\n\t\t\t\t//\t\tfxaaQualityEdgeThresholdMin\n\t\t\t\t// In order to insure AA does not get turned off on colors\n\t\t\t\t// which contain a minor amount of green.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_GREEN_AS_LUMA 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_EARLY_EXIT\n\t\t\t\t//\n\t\t\t\t// Controls algorithm\'s early exit path.\n\t\t\t\t// On PS3 turning this ON adds 2 cycles to the shader.\n\t\t\t\t// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n\t\t\t\t// Turning this off on console will result in a more blurry image.\n\t\t\t\t// So this defaults to on.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_EARLY_EXIT 1\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_DISCARD\n\t\t\t\t//\n\t\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t\t//\n\t\t\t\t// 1 = Use discard on pixels which don\'t need AA.\n\t\t\t\t//\t\t For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t\t// 0 = Return unchanged color on pixels which don\'t need AA.\n\t\t\t\t//\n\t\t\t\t#define FXAA_DISCARD 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t//\n\t\t\t\t// Used for GLSL 120 only.\n\t\t\t\t//\n\t\t\t\t// 1 = GL API supports fast pixel offsets\n\t\t\t\t// 0 = do not use fast pixel offsets\n\t\t\t\t//\n\t\t\t\t#ifdef GL_EXT_gpu_shader4\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 0\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t//\n\t\t\t\t// 1 = API supports gather4 on alpha channel.\n\t\t\t\t// 0 = API does not support gather4 on alpha channel.\n\t\t\t\t//\n\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 0\n\t\t\t\t#endif\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - TUNING KNOBS\n\t\t------------------------------------------------------------------------------\n\t\tNOTE the other tuning knobs are now in the shader function inputs!\n\t\t============================================================================*/\n\t\t#ifndef FXAA_QUALITY_PRESET\n\t\t\t\t//\n\t\t\t\t// Choose the quality preset.\n\t\t\t\t// This needs to be compiled into the shader as it effects code.\n\t\t\t\t// Best option to include multiple presets is to\n\t\t\t\t// in each shader define the preset, then include this file.\n\t\t\t\t//\n\t\t\t\t// OPTIONS\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n\t\t\t\t// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n\t\t\t\t// 39\t\t\t - no dither, very expensive\n\t\t\t\t//\n\t\t\t\t// NOTES\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n\t\t\t\t// 13 = about same speed as FXAA 3.9 and better than 12\n\t\t\t\t// 23 = closest to FXAA 3.9 visually and performance wise\n\t\t\t\t//\t_ = the lowest digit is directly related to performance\n\t\t\t\t// _\t= the highest digit is directly related to style\n\t\t\t\t//\n\t\t\t\t#define FXAA_QUALITY_PRESET 12\n\t\t#endif\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - PRESETS\n\n\t\t============================================================================*/\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - MEDIUM DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 10)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 3.0\n\t\t\t\t#define FXAA_QUALITY_P2 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 11)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 3.0\n\t\t\t\t#define FXAA_QUALITY_P3 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 12)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 4.0\n\t\t\t\t#define FXAA_QUALITY_P4 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 13)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 4.0\n\t\t\t\t#define FXAA_QUALITY_P5 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 14)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 4.0\n\t\t\t\t#define FXAA_QUALITY_P6 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 15)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 12.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - LOW DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 20)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 2.0\n\t\t\t\t#define FXAA_QUALITY_P2 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 21)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 22)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 23)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 24)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 3.0\n\t\t\t\t#define FXAA_QUALITY_P6 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 25)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 26)\n\t\t\t\t#define FXAA_QUALITY_PS 9\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 4.0\n\t\t\t\t#define FXAA_QUALITY_P8 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 27)\n\t\t\t\t#define FXAA_QUALITY_PS 10\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 4.0\n\t\t\t\t#define FXAA_QUALITY_P9 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 28)\n\t\t\t\t#define FXAA_QUALITY_PS 11\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 4.0\n\t\t\t\t#define FXAA_QUALITY_P10 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 29)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - EXTREME QUALITY\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 39)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.0\n\t\t\t\t#define FXAA_QUALITY_P2 1.0\n\t\t\t\t#define FXAA_QUALITY_P3 1.0\n\t\t\t\t#define FXAA_QUALITY_P4 1.0\n\t\t\t\t#define FXAA_QUALITY_P5 1.5\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAPI PORTING\n\n\t\t============================================================================*/\n\t\t#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard discard\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 vec2\n\t\t\t\t#define FxaaFloat3 vec3\n\t\t\t\t#define FxaaFloat4 vec4\n\t\t\t\t#define FxaaHalf float\n\t\t\t\t#define FxaaHalf2 vec2\n\t\t\t\t#define FxaaHalf3 vec3\n\t\t\t\t#define FxaaHalf4 vec4\n\t\t\t\t#define FxaaInt2 ivec2\n\t\t\t\t#define FxaaSat(x) clamp(x, 0.0, 1.0)\n\t\t\t\t#define FxaaTex sampler2D\n\t\t#else\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard clip(-1)\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 float2\n\t\t\t\t#define FxaaFloat3 float3\n\t\t\t\t#define FxaaFloat4 float4\n\t\t\t\t#define FxaaHalf half\n\t\t\t\t#define FxaaHalf2 half2\n\t\t\t\t#define FxaaHalf3 half3\n\t\t\t\t#define FxaaHalf4 half4\n\t\t\t\t#define FxaaSat(x) saturate(x)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n\t\t\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_120 == 1)\n\t\t\t\t// Requires,\n\t\t\t\t//\t#version 120\n\t\t\t\t// And at least,\n\t\t\t\t//\t#extension GL_EXT_gpu_shader4 : enable\n\t\t\t\t//\t(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n\t\t\t\t#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n\t\t\t\t#if (FXAA_FAST_PIXEL_OFFSET == 1)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n\t\t\t\t#else\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n\t\t\t\t#endif\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_130 == 1)\n\t\t\t\t// Requires "#version 130" or better\n\t\t\t\t#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_3 == 1)\n\t\t\t\t#define FxaaInt2 float2\n\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n\t\t\t\t#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_4 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n\t\t\t\t#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n\t\t\t\t#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t GREEN AS LUMA OPTION SUPPORT FUNCTION\n\t\t============================================================================*/\n\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n\t\t#else\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n\t\t#endif\n\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA3 QUALITY - PC\n\n\t\t============================================================================*/\n\t\t#if (FXAA_PC == 1)\n\t\t/*--------------------------------------------------------------------------*/\n\t\tFxaaFloat4 FxaaPixelShader(\n\t\t\t\t//\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy} = center of pixel\n\t\t\t\tFxaaFloat2 pos,\n\t\t\t\t//\n\t\t\t\t// Used only for FXAA Console, and not used on the 360 version.\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy_} = upper left of pixel\n\t\t\t\t// {_zw} = lower right of pixel\n\t\t\t\tFxaaFloat4 fxaaConsolePosPos,\n\t\t\t\t//\n\t\t\t\t// Input color texture.\n\t\t\t\t// {rgb_} = color in linear or perceptual color space\n\t\t\t\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t//\t\t {__a} = luma in perceptual color space (not linear)\n\t\t\t\tFxaaTex tex,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 2nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -1.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 3nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -2.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x_} = 1.0/screenWidthInPixels\n\t\t\t\t// {_y} = 1.0/screenHeightInPixels\n\t\t\t\tFxaaFloat2 fxaaQualityRcpFrame,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// This effects sub-pixel AA quality and inversely sharpness.\n\t\t\t\t//\t Where N ranges between,\n\t\t\t\t//\t\t N = 0.50 (default)\n\t\t\t\t//\t\t N = 0.33 (sharper)\n\t\t\t\t// {x__} = -N/screenWidthInPixels\n\t\t\t\t// {_y_} = -N/screenHeightInPixels\n\t\t\t\t// {_z_} =\tN/screenWidthInPixels\n\t\t\t\t// {__w} =\tN/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Not used on 360, but used on PS3 and PC.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} = -2.0/screenWidthInPixels\n\t\t\t\t// {_y_} = -2.0/screenHeightInPixels\n\t\t\t\t// {_z_} =\t2.0/screenWidthInPixels\n\t\t\t\t// {__w} =\t2.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} =\t8.0/screenWidthInPixels\n\t\t\t\t// {_y_} =\t8.0/screenHeightInPixels\n\t\t\t\t// {_z_} = -4.0/screenWidthInPixels\n\t\t\t\t// {__w} = -4.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_SUBPIX define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Choose the amount of sub-pixel aliasing removal.\n\t\t\t\t// This can effect sharpness.\n\t\t\t\t//\t 1.00 - upper limit (softer)\n\t\t\t\t//\t 0.75 - default amount of filtering\n\t\t\t\t//\t 0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t\t\t\t//\t 0.25 - almost off\n\t\t\t\t//\t 0.00 - completely off\n\t\t\t\tFxaaFloat fxaaQualitySubpix,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// The minimum amount of local contrast required to apply algorithm.\n\t\t\t\t//\t 0.333 - too little (faster)\n\t\t\t\t//\t 0.250 - low quality\n\t\t\t\t//\t 0.166 - default\n\t\t\t\t//\t 0.125 - high quality\n\t\t\t\t//\t 0.063 - overkill (slower)\n\t\t\t\tFxaaFloat fxaaQualityEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t//\t 0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t\t\t\t//\t 0.0625 - high quality (faster)\n\t\t\t\t//\t 0.0312 - visible limit (slower)\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only three safe values here: 2 and 4 and 8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// For all other platforms can be a non-power of two.\n\t\t\t\t//\t 8.0 is sharper (default!!!)\n\t\t\t\t//\t 4.0 is softer\n\t\t\t\t//\t 2.0 is really soft (good only for vector graphics inputs)\n\t\t\t\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only two safe values here: 1/4 and 1/8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// Other platforms can use other values.\n\t\t\t\t//\t 0.125 leaves less aliasing, but is softer (default!!!)\n\t\t\t\t//\t 0.25 leaves more aliasing, and is sharper\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t\t\t\t// This does not apply to PS3,\n\t\t\t\t// PS3 was simplified to avoid more shader instructions.\n\t\t\t\t//\t 0.06 - faster but more aliasing in darks\n\t\t\t\t//\t 0.05 - default\n\t\t\t\t//\t 0.04 - slower and less aliasing in darks\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Extra constants for 360 FXAA Console only.\n\t\t\t\t// Use zeros or anything else for other platforms.\n\t\t\t\t// These must be in physical constant registers and NOT immediates.\n\t\t\t\t// Immediates will result in compiler un-optimizing.\n\t\t\t\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\t\t\t\tFxaaFloat4 fxaaConsole360ConstDir\n\t\t) {\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posM;\n\t\t\t\tposM.x = pos.x;\n\t\t\t\tposM.y = pos.y;\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t#define lumaM luma4A.w\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#define lumaE luma4A.z\n\t\t\t\t\t\t#define lumaS luma4A.x\n\t\t\t\t\t\t#define lumaSE luma4A.y\n\t\t\t\t\t\t#define lumaNW luma4B.w\n\t\t\t\t\t\t#define lumaN luma4B.z\n\t\t\t\t\t\t#define lumaW luma4B.x\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat maxSM = max(lumaS, lumaM);\n\t\t\t\tFxaaFloat minSM = min(lumaS, lumaM);\n\t\t\t\tFxaaFloat maxESM = max(lumaE, maxSM);\n\t\t\t\tFxaaFloat minESM = min(lumaE, minSM);\n\t\t\t\tFxaaFloat maxWN = max(lumaN, lumaW);\n\t\t\t\tFxaaFloat minWN = min(lumaN, lumaW);\n\t\t\t\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\t\t\t\tFxaaFloat rangeMin = min(minWN, minESM);\n\t\t\t\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\t\t\t\tFxaaFloat range = rangeMax - rangeMin;\n\t\t\t\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\t\t\t\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(earlyExit)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\tFxaaDiscard;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn rgbyM;\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 0)\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNS = lumaN + lumaS;\n\t\t\t\tFxaaFloat lumaWE = lumaW + lumaE;\n\t\t\t\tFxaaFloat subpixRcpRange = 1.0/range;\n\t\t\t\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\t\t\t\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\t\t\t\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\t\t\t\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\t\t\t\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\t\t\t\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\t\t\t\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\t\t\t\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\t\t\t\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\t\t\t\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\t\t\t\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\t\t\t\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\t\t\t\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\t\t\t\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\t\t\t\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\t\t\t\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!horzSpan) lumaN = lumaW;\n\t\t\t\tif(!horzSpan) lumaS = lumaE;\n\t\t\t\tif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\t\t\t\tFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat gradientN = lumaN - lumaM;\n\t\t\t\tFxaaFloat gradientS = lumaS - lumaM;\n\t\t\t\tFxaaFloat lumaNN = lumaN + lumaM;\n\t\t\t\tFxaaFloat lumaSS = lumaS + lumaM;\n\t\t\t\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\t\t\t\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\t\t\t\tif(pairN) lengthSign = -lengthSign;\n\t\t\t\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posB;\n\t\t\t\tposB.x = posM.x;\n\t\t\t\tposB.y = posM.y;\n\t\t\t\tFxaaFloat2 offNP;\n\t\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\t\t\t\tif(!horzSpan) posB.x += lengthSign * 0.5;\n\t\t\t\tif( horzSpan) posB.y += lengthSign * 0.5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posN;\n\t\t\t\tposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat2 posP;\n\t\t\t\tposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\t\t\t\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\t\t\t\tFxaaFloat subpixE = subpixC * subpixC;\n\t\t\t\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!pairN) lumaNN = lumaSS;\n\t\t\t\tFxaaFloat gradientScaled = gradient * 1.0/4.0;\n\t\t\t\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\t\t\t\tFxaaFloat subpixF = subpixD * subpixE;\n\t\t\t\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tlumaEndN -= lumaNN * 0.5;\n\t\t\t\tlumaEndP -= lumaNN * 0.5;\n\t\t\t\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n\t\t\t\tFxaaBool doneNP = (!doneN) || (!doneP);\n\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 3)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 4)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 5)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 6)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 7)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PS > 8)\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 9)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 10)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 11)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 12)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat dstN = posM.x - posN.x;\n\t\t\t\tFxaaFloat dstP = posP.x - posM.x;\n\t\t\t\tif(!horzSpan) dstN = posM.y - posN.y;\n\t\t\t\tif(!horzSpan) dstP = posP.y - posM.y;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLength = (dstP + dstN);\n\t\t\t\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLengthRcp = 1.0/spanLength;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool directionN = dstN < dstP;\n\t\t\t\tFxaaFloat dst = min(dstN, dstP);\n\t\t\t\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\t\t\t\tFxaaFloat subpixG = subpixF * subpixF;\n\t\t\t\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\t\t\t\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\t\t\t\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\t\t\t\tif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\t\t\t\tif( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\treturn FxaaTexTop(tex, posM);\n\t\t\t\t#else\n\t\t\t\t\t\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n\t\t\t\t#endif\n\t\t}\n\t\t/*==========================================================================*/\n\t\t#endif\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\tvUv,\n\t\t\t\tvec4(0.0),\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\tresolution,\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\t0.75,\n\t\t\t\t0.166,\n\t\t\t\t0.0833,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\tvec4(0.0)\n\t\t\t);\n\n\t\t\t// TODO avoid querying texture twice for same texel\n\t\t\tgl_FragColor.a = texture2D(tDiffuse, vUv).a;\n\t\t}'};function ue(t){return ue="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ue(t)}function le(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function de(t,e){return de=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},de(t,e)}function ce(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=fe(t);if(e){var r=fe(this).constructor;n=Reflect.construct(i,arguments,r)}else n=i.apply(this,arguments);return he(this,n)}}function he(t,e){if(e&&("object"===ue(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function fe(t){return fe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},fe(t)}var pe,me=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&de(t,e)}(o,t);var e,n,i,r=ce(o);function o(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),r.call(this,se)}return e=o,(n=[{key:"setSize",value:function(t,e){var n=this.material.uniforms.resolution.value;n.x=1/t,n.y=1/e}}])&&le(e.prototype,n),i&&le(e,i),o}(b),ge=new i.WebGLRenderer({powerPreference:"high-performance",stencil:!1});ge.toneMapping=i.ACESFilmicToneMapping,L.init(ge);var ve=ge.domElement;document.getElementById("main").appendChild(ve);var xe=new class{constructor(t,e){if(this.renderer=t,void 0===e){const n={minFilter:i.LinearFilter,magFilter:i.LinearFilter,format:i.RGBAFormat},r=t.getSize(new i.Vector2);this._pixelRatio=t.getPixelRatio(),this._width=r.width,this._height=r.height,(e=new i.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,n)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===g&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===b&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new b(g),this.clock=new i.Clock}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let n=!1;for(let e=0,i=this.passes.length;e<i;e++){const i=this.passes[e];if(!1!==i.enabled){if(i.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(e),i.render(this.renderer,this.writeBuffer,this.readBuffer,t,n),i.needsSwap){if(n){const e=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),n.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==_&&(i instanceof _?n=!0:i instanceof N&&(n=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new i.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const n=this._width*this._pixelRatio,i=this._height*this._pixelRatio;this.renderTarget1.setSize(n,i),this.renderTarget2.setSize(n,i);for(let t=0;t<this.passes.length;t++)this.passes[t].setSize(n,i)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}}(ge);pe={renderer:ge,canvas:ve,composer:xe,init:function(){var t=m.scene,e=m.camera,n=window,r=n.innerWidth,o=n.innerHeight,a=n.devicePixelRatio||1,s=Math.round(r/a),u=Math.round(o/a),l=new i.Vector2(s,u);pe.resolution=l;var d={render:new F(t,e),fxaa:new me,adjustments:new ae};Object.values(d).forEach((function(t){return xe.addPass(t)})),pe.post=d},resize:function(t,e,n){ge.setPixelRatio(n),ge.setSize(t,e),xe.setSize(t,e),Object.values(pe.post).forEach((function(i){i.setSize&&i.setSize(t,e,n)}))},update:function(){xe.render()}};class ye{constructor(t=.1,e=6){this.maxEdgeLength=t,this.maxIterations=e}modify(t){if(!0===t.isGeometry)return console.error("THREE.TessellateModifier no longer supports Geometry. Use BufferGeometry instead."),t;null!==t.index&&(t=t.toNonIndexed());const e=this.maxIterations,n=this.maxEdgeLength*this.maxEdgeLength,r=new i.Vector3,o=new i.Vector3,a=new i.Vector3,s=new i.Vector3,u=[r,o,a,s],l=new i.Vector3,d=new i.Vector3,c=new i.Vector3,h=new i.Vector3,f=[l,d,c,h],p=new i.Color,m=new i.Color,g=new i.Color,v=new i.Color,x=[p,m,g,v],y=new i.Vector2,A=new i.Vector2,b=new i.Vector2,_=new i.Vector2,N=[y,A,b,_],T=new i.Vector2,F=new i.Vector2,S=new i.Vector2,w=new i.Vector2,P=[T,F,S,w],L=t.attributes,O=void 0!==L.normal,E=void 0!==L.color,I=void 0!==L.uv,R=void 0!==L.uv2;let C=L.position.array,U=O?L.normal.array:null,M=E?L.color.array:null,D=I?L.uv.array:null,X=R?L.uv2.array:null,z=C,Y=U,J=M,k=D,Q=X,B=0,H=!0;function V(t,e,n){const i=u[t],r=u[e],o=u[n];if(z.push(i.x,i.y,i.z),z.push(r.x,r.y,r.z),z.push(o.x,o.y,o.z),O){const i=f[t],r=f[e],o=f[n];Y.push(i.x,i.y,i.z),Y.push(r.x,r.y,r.z),Y.push(o.x,o.y,o.z)}if(E){const i=x[t],r=x[e],o=x[n];J.push(i.x,i.y,i.z),J.push(r.x,r.y,r.z),J.push(o.x,o.y,o.z)}if(I){const i=N[t],r=N[e],o=N[n];k.push(i.x,i.y),k.push(r.x,r.y),k.push(o.x,o.y)}if(R){const i=P[t],r=P[e],o=P[n];Q.push(i.x,i.y),Q.push(r.x,r.y),Q.push(o.x,o.y)}}for(;H&&B<e;){B++,H=!1,C=z,z=[],O&&(U=Y,Y=[]),E&&(M=J,J=[]),I&&(D=k,k=[]),R&&(X=Q,Q=[]);for(let t=0,e=0,i=C.length;t<i;t+=9,e+=6){r.fromArray(C,t+0),o.fromArray(C,t+3),a.fromArray(C,t+6),O&&(l.fromArray(U,t+0),d.fromArray(U,t+3),c.fromArray(U,t+6)),E&&(p.fromArray(M,t+0),m.fromArray(M,t+3),g.fromArray(M,t+6)),I&&(y.fromArray(D,e+0),A.fromArray(D,e+2),b.fromArray(D,e+4)),R&&(T.fromArray(X,e+0),F.fromArray(X,e+2),S.fromArray(X,e+4));const i=r.distanceToSquared(o),u=o.distanceToSquared(a),f=r.distanceToSquared(a);i>n||u>n||f>n?(H=!0,i>=u&&i>=f?(s.lerpVectors(r,o,.5),O&&h.lerpVectors(l,d,.5),E&&v.lerpColors(p,m,.5),I&&_.lerpVectors(y,A,.5),R&&w.lerpVectors(T,F,.5),V(0,3,2),V(3,1,2)):u>=i&&u>=f?(s.lerpVectors(o,a,.5),O&&h.lerpVectors(d,c,.5),E&&v.lerpColors(m,g,.5),I&&_.lerpVectors(A,b,.5),R&&w.lerpVectors(F,S,.5),V(0,1,3),V(3,2,0)):(s.lerpVectors(r,a,.5),O&&h.lerpVectors(l,c,.5),E&&v.lerpColors(p,g,.5),I&&_.lerpVectors(y,b,.5),R&&w.lerpVectors(T,S,.5),V(0,1,3),V(3,1,2))):V(0,1,2)}}const G=new i.BufferGeometry;return G.setAttribute("position",new i.Float32BufferAttribute(z,3)),O&&G.setAttribute("normal",new i.Float32BufferAttribute(Y,3)),E&&G.setAttribute("color",new i.Float32BufferAttribute(J,3)),I&&G.setAttribute("uv",new i.Float32BufferAttribute(k,2)),R&&G.setAttribute("uv2",new i.Float32BufferAttribute(Q,2)),G}}function Ae(t){var e,n=this,i=(e=4022871197,function(t){t=String(t);for(var n=0;n<t.length;n++){var i=.02519603282416938*(e+=t.charCodeAt(n));i-=e=i>>>0,e=(i*=e)>>>0,e+=4294967296*(i-=e)}return 2.3283064365386963e-10*(e>>>0)});n.random=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=i(" "),n.s1=i(" "),n.s2=i(" "),n.s0-=i(t),n.s0<0&&(n.s0+=1),n.s1-=i(t),n.s1<0&&(n.s1+=1),n.s2-=i(t),n.s2<0&&(n.s2+=1)}function be(t,e){return Math.floor(Math.random()*(e-t+1)+t)}function _e(t){return be(0,t)}const Ne={random:{int:be,uint:_e,item:function(t){return t[_e(t.length-1)]},boolean:function(){return Math.random()<.5}}},Te=[["black","white","red","green","blue","pink","purple","orange","silver","golden","iron","stone","velvet","opal","ivory","coral","broken","pearl","silk","fire","ice","thunder","falling","rising","diamond","turquoise","ruby","emerald","onyx","lapis","jade","amber"],["shield","sword","spear","arrow","knight","king","queen","phoenix","box","garden","flower","apple","echo","gambit","fist","dragon","sun","moon","star","cloud","rain","wind","dawn","storm","eagle","tiger","lion","puma","wolf","panther","dove","fox"]],Fe=[["loud","adorab","glad","zealous","grumpi","happi","polite","expert","awkward","warm","sincere","shy","quiet","lazi","mad","bold"].map((t=>`${t}ly`)),["beam","giggl","paint","smil","danc","laugh","sing","sneez","clapp","whistl","hopp","cheer","fly","greet","wav","juggl"].map((t=>`${t}ing`)),["smart","creative","bubbly","fun","cute","tiny","giant","laidback","upbeat","kind","cool","brave","dumb","tipsy","popular","generous"],["puppy","kitten","monkey","pumpkin","robot","nun","ninja","giraffe","baby","penguin","panda","koala","bear","wizard","pirate","knight"]],Se="abcdefghijklmnopqrstuvwxyz".split(""),we="aeiou".split(""),Pe=Se.filter((t=>!we.includes(t))),Le={alphabet:Se,vowels:we,consonnants:Pe},Oe={CODENAME:"codename",DESCRIPTION:"description",GIBBERISH:"gibberish",SERIAL:"serial"};const Ee={NONE:"",DASH:"-",DOT:".",TILDE:"~",UNDERSCORE:"_"};let Ie="";function Re(t){return Ne.random.item(t)}function Ce(){const{verbose:t,separator:e}=ze;return(t?[...Te.map(Re),Ne.random.uint(999)]:Te.map(Re)).join(e)}function Ue(){const{verbose:t,separator:e}=ze;return(t?Fe:[Fe[1],Fe[3]]).map(Re).join(e)}function Me(){const{verbose:t}=ze,{vowels:e,consonnants:n}=Le,i=t?8:4;return Array.from({length:i},((t,i)=>{const r=i%2?e:n;return Ne.random.item(r)})).join("")}function De(){const{verbose:t}=ze,e=t?8:4,n=Le.alphabet.filter((t=>!"ilo".includes(t)));return Array.from({length:e},(()=>ze.bool()?Ne.random.item(n).toUpperCase():Ne.random.int(1,9))).join("")}function Xe(){const{mode:t}=ze,e={codename:Ce,description:Ue,gibberish:Me,serial:De}[t]||Ce;return ze.seed=e(),ze.seed}const ze={modes:Oe,mode:Oe.CODENAME,separators:Ee,separator:Ee.NONE,verbose:!1,prng:new Ae(Ie),codename:Ce,description:Ue,gibberish:Me,serial:De,autoseed:Xe,reset:function(){ze.prng=new Ae(ze.seed)},random:function(t=0,e=1,n=!1){const{prng:i}=ze,r=i.random();return isNaN(t)||isNaN(e)?r:n?Math.floor(r*(e-t+1)+t):r*(e-t)+t},int:function(t,e){return ze.random(t,e,!0)},uint:function(t){return ze.int(0,t)},item:function(t){return t[ze.uint(t.length-1)]},bool:function(){return ze.random()<.5},char:function(t){return t.charAt(ze.uint(t.length-1))},get seed(){return Ie},set seed(t){Ie=t,this.reset()}};Xe();const Ye=ze;function Je(t){return function(t){if(Array.isArray(t))return ke(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return ke(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return ke(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ke(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function Qe(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var Be=function(){function t(e,n){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._f=e,this._category=n,this.update()}var e,n,i;return e=t,n=[{key:"update",value:function(){var e=this.f+this.category,n=t.glsl[e];n||(e="linear",n=t.glsl[e]),this._name=e,this._glsl=n}},{key:"f",get:function(){return this._f},set:function(t){this._f=t,this.update()}},{key:"category",get:function(){return this._category},set:function(t){this._category=t,this.update()}},{key:"name",get:function(){return this._name}},{key:"glsl",get:function(){return this._glsl}}],n&&Qe(e.prototype,n),i&&Qe(e,i),t}();function He(t){let e,n,r,o=0;for(let i=0;i<t.length;++i){const a=t[i];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===e&&(e=a.array.constructor),e!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=a.itemSize),n!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===r&&(r=a.normalized),r!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;o+=a.array.length}const a=new e(o);let s=0;for(let e=0;e<t.length;++e)a.set(t[e].array,s),s+=t[e].array.length;return new i.BufferAttribute(a,n,r)}Object.assign(Be,{get glsl(){return{linear:"float linear( float t ) {\r\n\treturn t;\r\n}",quadIn:"float quadIn( float t ) {\r\n\treturn t * t;\r\n}",quadOut:"float quadOut( float t ) {\r\n\treturn -t * ( t - 2.0 );\r\n}",quadInOut:"float quadInOut( float t ) {\r\n\tfloat p = 2.0 * t * t;\r\n\treturn t < 0.5 ? p : -p + ( 4.0 * t ) - 1.0;\r\n}",cubicIn:"float cubicIn( float t ) {\r\n\treturn t * t * t;\r\n}",cubicOut:"float cubicOut( float t ) {\r\n\tfloat f = t - 1.0;\r\n\treturn f * f * f + 1.0;\r\n}",cubicInOut:"float cubicInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t? 4.0 * t * t * t\r\n\t\t: 0.5 * pow( 2.0 * t - 2.0, 3.0 ) + 1.0;\r\n}",quartIn:"float quartIn( float t ) {\r\n\treturn pow( t, 4.0 );\r\n}",quartOut:"float quartOut( float t ) {\r\n\treturn pow( t - 1.0, 3.0 ) * ( 1.0 - t ) + 1.0;\r\n}",quartInOut:"float quartInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t? + 8.0 * pow( t, 4.0 )\r\n\t\t: - 8.0 * pow( t - 1.0, 4.0 ) + 1.0;\r\n}",quintIn:"float quintIn( float t ) {\r\n\treturn pow( t, 5.0 );\r\n}",quintOut:"float quintOut( float t ) {\r\n\treturn 1.0 - ( pow( 1.0 - t, 5.0 ) );\r\n}",quintInOut:"float quintInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t\t? +16.0 * pow( t, 5.0 )\r\n\t\t\t: -0.5 * pow( 2.0 * t - 2.0, 5.0 ) + 1.0;\r\n}",expoIn:"float expoIn( float t ) {\r\n\treturn t == 0.0 ? t : pow( 2.0, 10.0 * ( t - 1.0 ) );\r\n}",expoOut:"float expoOut( float t ) {\r\n\treturn t == 1.0 ? t : 1.0 - pow( 2.0, -10.0 * t );\r\n}",expoInOut:"float expoInOut( float t ) {\r\n\treturn t == 0.0 || t == 1.0\r\n\t\t? t\r\n\t\t: t < 0.5\r\n\t\t\t? +0.5 * pow( 2.0, ( 20.0 * t ) - 10.0 )\r\n\t\t\t: -0.5 * pow( 2.0, 10.0 - ( t * 20.0 ) ) + 1.0;\r\n}",circIn:"float circIn( float t ) {\r\n\treturn 1.0 - sqrt( 1.0 - t * t );\r\n}",circOut:"float circOut( float t ) {\r\n\treturn sqrt( ( 2.0 - t ) * t );\r\n}",circInOut:"float circInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t? 0.5 * ( 1.0 - sqrt( 1.0 - 4.0 * t * t ) )\r\n\t\t: 0.5 * ( sqrt( ( 3.0 - 2.0 * t ) * ( 2.0 * t - 1.0 ) ) + 1.0 );\r\n}",sineIn:"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat sineIn( float t ) {\r\n\treturn sin( ( t - 1.0 ) * HALF_PI ) + 1.0;\r\n}",sineOut:"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat sineOut( float t ) {\r\n\treturn sin( t * HALF_PI );\r\n}",sineInOut:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat sineInOut( float t ) {\r\n\treturn -0.5 * ( cos( PI * t ) - 1.0 );\r\n}",backIn:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat backIn( float t ) {\r\n\treturn pow( t, 3.0 ) - t * sin( t * PI );\r\n}",backOut:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat backOut( float t ) {\r\n\tfloat f = 1.0 - t;\r\n\treturn 1.0 - ( pow( f, 3.0 ) - f * sin( f * PI ) );\r\n}",backInOut:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat backInOut( float t ) {\r\n\tfloat f = t < 0.5\r\n\t\t? 2.0 * t\r\n\t\t: 1.0 - ( 2.0 * t - 1.0 );\r\n\r\n\tfloat g = pow( f, 3.0 ) - f * sin( f * PI );\r\n\r\n\treturn t < 0.5\r\n\t\t? 0.5 * g\r\n\t\t: 0.5 * ( 1.0 - g ) + 0.5;\r\n}",bounceIn:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\n#ifndef bounceOut\r\nfloat bounceOut( float t ) {\r\n\tconst float a = 4.0 / 11.0;\r\n\tconst float b = 8.0 / 11.0;\r\n\tconst float c = 9.0 / 10.0;\r\n\r\n\tconst float ca = 4356.0 / 361.0;\r\n\tconst float cb = 35442.0 / 1805.0;\r\n\tconst float cc = 16061.0 / 1805.0;\r\n\r\n\tfloat t2 = t * t;\r\n\r\n\treturn t < a\r\n\t\t? 7.5625 * t2\r\n\t\t: t < b\r\n\t\t\t? 9.075 * t2 - 9.9 * t + 3.4\r\n\t\t\t: t < c\r\n\t\t\t\t? ca * t2 - cb * t + cc\r\n\t\t\t\t: 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n#endif\r\n\r\nfloat bounceIn( float t ) {\r\n\treturn 1.0 - bounceOut( 1.0 - t );\r\n}",bounceOut:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat bounceOut( float t ) {\r\n\tconst float a = 4.0 / 11.0;\r\n\tconst float b = 8.0 / 11.0;\r\n\tconst float c = 9.0 / 10.0;\r\n\r\n\tconst float ca = 4356.0 / 361.0;\r\n\tconst float cb = 35442.0 / 1805.0;\r\n\tconst float cc = 16061.0 / 1805.0;\r\n\r\n\tfloat t2 = t * t;\r\n\r\n\treturn t < a\r\n\t\t? 7.5625 * t2\r\n\t\t: t < b\r\n\t\t\t? 9.075 * t2 - 9.9 * t + 3.4\r\n\t\t\t: t < c\r\n\t\t\t\t? ca * t2 - cb * t + cc\r\n\t\t\t\t: 10.8 * t * t - 20.52 * t + 10.72;\r\n}",bounceInOut:"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\n#ifndef bounceOut\r\nfloat bounceOut( float t ) {\r\n\tconst float a = 4.0 / 11.0;\r\n\tconst float b = 8.0 / 11.0;\r\n\tconst float c = 9.0 / 10.0;\r\n\r\n\tconst float ca = 4356.0 / 361.0;\r\n\tconst float cb = 35442.0 / 1805.0;\r\n\tconst float cc = 16061.0 / 1805.0;\r\n\r\n\tfloat t2 = t * t;\r\n\r\n\treturn t < a\r\n\t\t? 7.5625 * t2\r\n\t\t: t < b\r\n\t\t\t? 9.075 * t2 - 9.9 * t + 3.4\r\n\t\t\t: t < c\r\n\t\t\t\t? ca * t2 - cb * t + cc\r\n\t\t\t\t: 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n#endif\r\n\r\nfloat bounceInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t? 0.5 * ( 1.0 - bounceOut( 1.0 - t * 2.0 ) )\r\n\t\t: 0.5 * bounceOut( t * 2.0 - 1.0 ) + 0.5;\r\n}",elasticIn:"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat elasticIn( float t ) {\r\n\treturn sin( 13.0 * t * HALF_PI ) * pow( 2.0, 10.0 * ( t - 1.0 ) );\r\n}",elasticOut:"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat elasticOut( float t ) {\r\n\treturn sin( -13.0 * ( t + 1.0 ) * HALF_PI ) * pow( 2.0, -10.0 * t ) + 1.0;\r\n}",elasticInOut:"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat elasticInOut( float t ) {\r\n\treturn t < 0.5\r\n\t\t? 0.5 * sin( +13.0 * HALF_PI * 2.0 * t ) * pow( 2.0, 10.0 * ( 2.0 * t - 1.0 ) )\r\n\t\t: 0.5 * sin( -13.0 * HALF_PI * ( ( 2.0 * t - 1.0 ) + 1.0 ) ) * \r\n\t\t\tpow( 2.0, -10.0 * ( 2.0 * t - 1.0 ) ) + 1.0;\r\n}"}},get functions(){return Je(new Set(Object.keys(Be.glsl).map((function(t){return t.replace(/([a-z]*)(InOut|In|Out)/,"$1")}))))},get categories(){return["In","Out","InOut"]}});function Ve(t){return Ve="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ve(t)}function Ge(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function je(t,e){return je=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},je(t,e)}function qe(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=Ke(t);if(e){var r=Ke(this).constructor;n=Reflect.construct(i,arguments,r)}else n=i.apply(this,arguments);return We(this,n)}}function We(t,e){if(e&&("object"===Ve(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function Ke(t){return Ke=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},Ke(t)}var Ze=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&je(t,e)}(n,t);var e=qe(n);function n(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=i.min,o=void 0===r?0:r,a=i.max,s=void 0===a?1:a,u=i.scale,l=void 0===u?1:u,d=i.seed,c=void 0===d?Math.random():d;return Ge(this,n),e.call(this,t,n.shader,{uMin:{value:o},uMax:{value:s},uScale:{value:l},uSeed:{value:c}})}return n}(L);function $e(t){return $e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$e(t)}function tn(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function en(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function nn(t,e){return nn=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},nn(t,e)}function rn(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=sn(t);if(e){var r=sn(this).constructor;n=Reflect.construct(i,arguments,r)}else n=i.apply(this,arguments);return on(this,n)}}function on(t,e){if(e&&("object"===$e(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return an(t)}function an(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function sn(t){return sn=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},sn(t)}Ze.formatUniforms=function(t){return{uMin:{value:t.min},uMax:{value:t.max},uScale:{value:t.scale},uSeed:{value:t.seed}}},Ze.shader="\n\n\tuniform float uMin;\n\tuniform float uMax;\n\tuniform float uScale;\n\tuniform float uSeed;\n\tuniform sampler2D tData;\n\n    ".concat(S.glsl,"\n\t").concat("//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute( vec4 x ){ return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 ); }\nvec4 taylorInvSqrt( vec4 r ){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat simplex3D( float vx, float vy, float vz ) {\n\n\tvec3 v = vec3( vx, vy, vz );\n\t\n\tconst vec2 C = vec2( 1.0/6.0, 1.0/3.0   );\n\tconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n\t// First corner\n\tvec3 i  = floor( v + dot( v, C.yyy ) );\n\tvec3 x0 =   v - i + dot( i, C.xxx ) ;\n\n\t// Other corners\n\tvec3 g = step( x0.yzx, x0.xyz );\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(  g.xyz, l.zxy );\n\tvec3 i2 = max(  g.xyz, l.zxy );\n\n\t// x0 = x0 - 0. + 0.0 * C \n\tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t// Permutations\n\ti = mod( i, 289.0 ); \n\tvec4 p = permute( permute( permute(\n\t\t\t i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n\t\t   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) \n\t\t   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n\t// Gradients\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  \tfloat n_ = 1.0/7.0; // N=7\n  \tvec3  ns = n_ * D.wyz - D.xzx;\n\n  \tvec4 j = p - 49.0 * floor( p * ns.z *ns.z ); //  mod( p,N*N)\n\n  \tvec4 x_ = floor( j * ns.z );\n  \tvec4 y_ = floor( j - 7.0 * x_ ); // mod( j,N)\n\n  \tvec4 x = x_ *ns.x + ns.yyyy;\n  \tvec4 y = y_ *ns.x + ns.yyyy;\n  \tvec4 h = 1.0 - abs( x ) - abs( y );\n\n  \tvec4 b0 = vec4( x.xy, y.xy );\n  \tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor( b0 )*2.0 + 1.0;\n  \tvec4 s1 = floor( b1 )*2.0 + 1.0;\n  \tvec4 sh = -step( h, vec4( 0.0 ) );\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3( a0.xy,h.x );\n  \tvec3 p1 = vec3( a0.zw,h.y );\n  \tvec3 p2 = vec3( a1.xy,h.z );\n  \tvec3 p3 = vec3( a1.zw,h.w );\n\n\t//Normalise gradients\n  \tvec4 norm = taylorInvSqrt( \n\t\tvec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) )\n\t);\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max( \n\t\t0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), \n\t\t0.0\n\t);\n  \tm = m * m;\n  \treturn 42.0 * dot( \n\t\tm*m,\n\t\tvec4( dot( p0,x0 ), dot( p1,x1 ), dot( p2,x2 ), dot( p3,x3 ) )\n\t);\n\n}","\n\n    void main() {\n        \n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\t\tfloat noise = 0.5 + simplex3D( \n\t\t\tuv.x * uScale, \n\t\t\tuv.y * uScale, \n\t\t\tuSeed * uScale\n\t\t) / 2.0;\n\n\t\tfloat data = noise * ( uMax - uMin ) + uMin;\n\n        gl_FragColor = pack( data );\n\n    }\n\n");var un=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&nn(t,e)}(a,t);var e,n,r,o=rn(a);function a(t,e){var n,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=i.density,s=i.reversed,u=i.easing,l=i.maxEdgeLength,d=i.maxIterations,c=i.spread,h=i.turbulence,f=i.stagger,p=i.dynamics,m=i.delay,g=i.wind,v=i.duration;tn(this,a);var x=new ye(l,d);return t=x.modify(t),t=a.densify(t,r),(n=o.call(this,t,e)).options={reversed:s,easing:u,spread:c,turbulence:h,delay:m,duration:v,stagger:f,dynamics:p,wind:g},n.setAttributes(),n.setChunks(),n.material.onBeforeCompile=n.onBeforeCompile.bind(an(n)),n}return e=a,n=[{key:"setAttributes",value:function(){for(var t=this.geometry,e=t.attributes.position.array,n=t.attributes.position.count,r=Math.ceil(n/3),o=new Float32Array(n),s=new Float32Array(2*n),u=new Float32Array(3*n),l=a.computeCentroid,d=0;d<r;d++)for(var c=3*d,h=2*c,f=3*c,p=d%r/r,m=~~(d/r)/r,g=Math.random(),v=0;v<3;v++){o[c+v]=g;var x=h+2*v;s[x]=p,s[x+1]=m;var y=f+3*v;u[y]=l(f,e),u[y+1]=l(f+1,e),u[y+2]=l(f+2,e)}t.setAttribute("aNoise",new i.BufferAttribute(o,1)),t.setAttribute("aDataCoord",new i.BufferAttribute(s,2)),t.setAttribute("aCentroid",new i.BufferAttribute(u,3));var A=new Ze(r),b=new Ze(r),_=new Ze(r);this.gpgpu={x:A,y:b,z:_},this.compute()}},{key:"compute",value:function(){var t=this.gpgpu,e=this.shader,n=this.options,i=n.spread,r={uMin:{value:-i},uMax:{value:i},uScale:{value:n.turbulence}};if(Object.values(t).forEach((function(t){t.uniforms=JSON.parse(JSON.stringify(r)),t.uniforms.uSeed={value:Ye.random()},t.compute()})),e){var o=e.uniforms;o.tNoiseX.value=t.x.texture,o.tNoiseY.value=t.y.texture,o.tNoiseZ.value=t.z.texture}}},{key:"setChunks",value:function(){var t=this.options,e=t.easing,n="\n\n\t\t\tuniform float uTime;\n\t\t\tuniform float uStagger;\n\t\t\tuniform float uDynamics;\n\t\t\tuniform float uDelay;\n\t\t\tuniform float uDuration;\n\t\t\tuniform vec3 uWind;\n\t\t\tuniform sampler2D tNoiseX;\n\t\t\tuniform sampler2D tNoiseY;\n\t\t\tuniform sampler2D tNoiseZ;\n\n\t\t\tattribute float aNoise;\n\t\t\tattribute vec2 aDataCoord;\n\t\t\tattribute vec3 aCentroid;\n\n\t\t\t".concat(S.glsl,"\n\t\t\t").concat(e.glsl,"\n\t\t"),i=t.reversed?"progress = 1.0 - progress;":"",r="\n\n\t\t\tfloat bias = 0.9;\n\t\t\tfloat noiseDuration = clamp(\n\t\t\t\t( 1.0 - aNoise ) * uDynamics * uDuration,\n\t\t\t\t0.0,\n\t\t\t\t0.9 * uDuration\n\t\t\t);\n\t\t\tfloat duration = uDuration - noiseDuration;\n\n\t\t\tfloat noiseDelay = aNoise * uStagger;\n\t\t\tfloat delay = uDelay + noiseDelay;\n\n\t\t\tfloat time = clamp( uTime - delay, 0.0, duration );\n\t\t\tfloat progress =  clamp( time / duration, 0.0, 1.0 );\n\t\t\t".concat(i,"\n\t\t\tprogress = ").concat(e.name,"( progress );\n\t\t\n\t\t\tfloat scale = clamp( 1.0 - progress, 0.0, 1.0 );\n\t\t\ttransformed -= aCentroid;\n\t\t\ttransformed *= scale;\n\t\t\ttransformed += aCentroid;\n\t\t\n\t\t\tfloat noiseX = unpack( texture2D( tNoiseX, aDataCoord ) );\n\t\t\tfloat noiseY = unpack( texture2D( tNoiseY, aDataCoord ) );\n\t\t\tfloat noiseZ = unpack( texture2D( tNoiseZ, aDataCoord ) );\n\t\t\t\n\t\t\ttransformed.x += ( noiseX + uWind.x ) * progress;\n\t\t\ttransformed.y += ( noiseY + uWind.y ) * progress;\n\t\t\ttransformed.z += ( noiseZ + uWind.z ) * progress;\n\n\t\t");this.chunks={declarations:n,modifications:r},this.material.dispose()}},{key:"onBeforeCompile",value:function(t){var e=this.gpgpu,n=this.options,i=n.duration,r=n.stagger,o=n.dynamics,a=n.delay,s=n.wind;Object.assign(t.uniforms,{uTime:{value:0},uStagger:{value:r},uDynamics:{value:o},uDelay:{value:a},uDuration:{value:i},uWind:{value:s},tNoiseX:{value:e.x.texture},tNoiseY:{value:e.y.texture},tNoiseZ:{value:e.z.texture}});var u="void main()",l="#include <begin_vertex>",d=this.chunks,c=d.declarations,h=d.modifications,f=t.vertexShader;f=(f=f.replace(u,c+u)).replace(l,l+h),t.vertexShader=f,this.shader=t}},{key:"update",value:function(t){this.shader.uniforms.uTime.value=t}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose(),Object.values(this.gpgpu).forEach((function(t){return t.dispose()}))}},{key:"totalVertices",get:function(){return this.geometry.attributes.position.count}}],n&&en(e.prototype,n),r&&en(e,r),a}(i.Mesh);un.densify=function(t,e){if(e<2||!Number.isInteger(e)||!Number.isFinite(e))return t;t.computeBoundingBox();var n=t.boundingBox,r=.01*Math.min(n.max.x-n.min.x,n.max.y-n.min.y,n.max.z-n.min.z),o=Array.from({length:e-1},(function(e,n){var i=t.clone(),o=1-r*(n+1);return i.scale(o,o,o),i}));return o.unshift(t),function(t,e=!1){const n=null!==t[0].index,r=new Set(Object.keys(t[0].attributes)),o=new Set(Object.keys(t[0].morphAttributes)),a={},s={},u=t[0].morphTargetsRelative,l=new i.BufferGeometry;let d=0;for(let i=0;i<t.length;++i){const c=t[i];let h=0;if(n!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in c.attributes){if(!r.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[t]&&(a[t]=[]),a[t].push(c.attributes[t]),h++}if(h!==r.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(u!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in c.morphAttributes){if(!o.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[t]&&(s[t]=[]),s[t].push(c.morphAttributes[t])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(c.userData),e){let t;if(n)t=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;t=c.attributes.position.count}l.addGroup(d,t,i),d+=t}}if(n){let e=0;const n=[];for(let i=0;i<t.length;++i){const r=t[i].index;for(let t=0;t<r.count;++t)n.push(r.getX(t)+e);e+=t[i].attributes.position.count}l.setIndex(n)}for(const t in a){const e=He(a[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;l.setAttribute(t,e)}for(const t in s){const e=s[t][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[t]=[];for(let n=0;n<e;++n){const e=[];for(let i=0;i<s[t].length;++i)e.push(s[t][i][n]);const i=He(e);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute."),null;l.morphAttributes[t].push(i)}}return l}(o)},un.computeCentroid=function(t,e){return(e[t]+e[t+3]+e[t+6])/3};const ln=dat.gui;function dn(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null==n)return;var i,r,o=[],a=!0,s=!1;try{for(n=n.call(t);!(a=(i=n.next()).done)&&(o.push(i.value),!e||o.length!==e);a=!0);}catch(t){s=!0,r=t}finally{try{a||null==n.return||n.return()}finally{if(s)throw r}}return o}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return cn(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return cn(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function cn(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}var hn,fn={debug:!0,grid:!0,maxEdgeLength:.05,maxIterations:6,geometry:"torus",density:4,spread:2,turbulence:12,stagger:300,dynamics:.5,wind:new i.Vector3(0,0,0),easing:new Be,easingFunction:"circ",easingCategory:"In",reversed:!1,duration:1e3,loopDuration:3e3,delay:850},pn={density:{min:1,max:10,step:1},spread:{min:1,max:10,step:.1},turbulence:{min:1,max:20,step:.1},stagger:{min:0,max:500,step:5},dynamics:{min:0,max:1,step:.01},x:{min:-5,max:5,step:.1},y:{min:-5,max:5,step:.1},z:{min:-5,max:5,step:.1},delay:{min:0,max:1e3,step:50},duration:{min:500,max:5e3,step:50},loopDuration:{min:1e3,max:7500,step:50}},mn=JSON.parse(JSON.stringify(pn));["x","y","z","loopDuration","defaultSeed"].forEach((function(t){return delete mn[t]})),mn.density.min=2,mn.density.max=6,mn.duration.min=1e3,hn={title:"Disintegrator",defaultSeed:"keda",ranges:pn,reset:function(){Object.entries(fn).forEach((function(t){var e=dn(t,2),n=e[0],i=e[1];hn[n]=i}));var t=hn,e=t.easingFunction,n=t.easingCategory;hn.easing=new Be(e,n),hn.wind.x=0,hn.wind.y=0,hn.wind.z=-4},random:mn};var gn,vn,xn=new ln.GUI;function yn(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null==n)return;var i,r,o=[],a=!0,s=!1;try{for(n=n.call(t);!(a=(i=n.next()).done)&&(o.push(i.value),!e||o.length!==e);a=!0);}catch(t){s=!0,r=t}finally{try{a||null==n.return||n.return()}finally{if(s)throw r}}return o}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return An(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return An(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function An(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function bn(){var t=vn,e=t.loopDuration,n=t.duration,i=t.stagger,r=t.delay;0!==e&&(vn.loopDuration=n+i+2*r)}xn.init=function(){function t(t,e,n,i){if(hn.ranges[n]){var r=hn.ranges[n],o=r.min,a=r.max,s=r.step;return t.add(e,n,o,a).step(s)}return t.add(e,n,i)}var e=xn.addFolder("Geometry");t(e,vn,"geometry",Object.keys(vn.geometries)),t(e,vn,"density").onFinishChange(vn.generate),e.open();var n=xn.addFolder("Spread");t(n,vn,"spread"),t(n,vn,"turbulence"),t(n,vn,"stagger"),t(n,vn,"dynamics"),n.open();var i=xn.addFolder("Wind");t(i,vn.wind,"x"),t(i,vn.wind,"y"),t(i,vn.wind,"z"),t(i,vn,"zeroWind"),i.open();var r=xn.addFolder("Animation");t(r,vn,"easingFunction",Be.functions),t(r,vn,"easingCategory",Be.categories),t(r,vn,"reversed"),t(r,vn,"duration"),t(r,vn,"loopDuration").listen(),t(r,vn,"delay"),r.open();var o=xn.addFolder("Settings");if(t(o,vn,"grid"),t(o,vn,"reset"),t(o,vn,"random"),o.open(),hn.debug){var a=window,s=a.innerWidth,u=a.devicePixelRatio||1;Math.ceil(s/u)<1024&&xn.close()}else xn.close()},gn={load:function(){return window.location.hash.replace("#","")},save:function(t){window.location.hash=t}},Ye.seed=hn.defaultSeed;var _n={box:function(){return new i.BoxBufferGeometry(1.5,1.5,1.5,64,64,64)},circle:function(){return new i.CircleBufferGeometry(1.1,720)},cylinder:function(){return new i.CylinderBufferGeometry(.9,.9,1.5,96,96)},tetra:function(){var t=new i.TetrahedronBufferGeometry(1.5);return t.rotateX(i.MathUtils.degToRad(15)),function(t){return new ye(.01,arguments.length>1&&void 0!==arguments[1]?arguments[1]:6).modify(t)}(t,14)},plane:function(){return new i.PlaneBufferGeometry(2,2,160,160)},sphere:function(){return new i.SphereBufferGeometry(1.1,128,128)},torus:function(){return new i.TorusBufferGeometry(.8,.35,128,128)},torusKnot:function(){return new i.TorusKnotBufferGeometry(.68,.28,256,64)}};function Nn(){!function(){var t=vn.mesh;t&&(t.dispose(),m.remove(t),delete vn.mesh)}();var t=_n[hn.geometry]();"tetra"!==hn.geometry&&(t=t.toNonIndexed());var e=new i.MeshStandardMaterial({side:i.DoubleSide}),n=new un(t,e,hn);vn.mesh=n,m.add(n),hn.debug&&console.log({vertices:n.totalVertices}),bn(),xn.updateDisplay(),vn.ticker&&vn.ticker.reset();var r=Ye.seed&&Ye.seed!==hn.defaultSeed?" #".concat(Ye.seed):"";document.title=hn.title+r}function Tn(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];hn.wind.x=0,hn.wind.y=0,hn.wind.z=0,t&&xn.updateDisplay()}vn={geometries:_n,init:function t(){var e=vn,n=e.reset,i=e.random,r=gn.load();r?r!==Ye.seed&&i(r):n(),window.addEventListener("hashchange",t)},generate:Nn,random:function(t){t?Ye.seed=t:(Ye.autoseed(),gn.save(Ye.seed));var e=function(t,e,n){return Math.round(Ye.random(t,e)/n)*n},n=Ye.item(Object.keys(vn.geometries).filter((function(t){return t!==hn.geometry})));if(hn.reset(),hn.geometry=n,Object.entries(hn.random).forEach((function(t){var n=yn(t,2),i=n[0],r=n[1],o=r.min,a=r.max,s=r.step;hn[i]=e(o,a,s)})),Tn(!1),Ye.random()>.25){var i=Ye.item(["x","y","z"]),r=hn.ranges[i],o=r.min,a=r.max,s=r.step;hn.wind[i]=e(o,a,s)}var u=["back","bounce","elastic"];hn.easingFunction=Ye.item(Be.functions.filter((function(t){return!u.includes(t)}))),hn.easingCategory=Ye.item(["In","InOut"]),hn.easing.f=hn.easingFunction,hn.easing.category=hn.easingCategory,Nn()},reset:function(){Ye.seed=hn.initialSeed,hn.reset(),vn.grid=hn.grid,gn.save(""),Nn()},update:function(t){var e=vn,n=e.mesh,i=e.ticker,r=e.loopDuration;n&&n.update(t),r>0&&t>r&&i.reset()},zeroWind:Tn,get geometry(){return hn.geometry},set geometry(t){hn.geometry=t,Nn()},get density(){return hn.density},set density(t){hn.density=t},get spread(){return hn.spread},set spread(t){hn.spread=t,vn.mesh.options.spread=t,vn.mesh.compute()},get turbulence(){return hn.turbulence},set turbulence(t){hn.turbulence=t,vn.mesh.options.turbulence=t,vn.mesh.compute()},get delay(){return hn.delay},set delay(t){hn.delay=t,vn.mesh.shader.uniforms.uDelay.value=t,bn()},get duration(){return hn.duration},set duration(t){hn.duration=t,vn.mesh.shader.uniforms.uDuration.value=t,bn()},get stagger(){return hn.stagger},set stagger(t){hn.stagger=t,vn.mesh.shader.uniforms.uStagger.value=t,bn()},get dynamics(){return hn.dynamics},set dynamics(t){hn.dynamics=t,vn.mesh.shader.uniforms.uDynamics.value=t},get wind(){return hn.wind},set wind(t){hn.wind=t},get loopDuration(){return hn.loopDuration},set loopDuration(t){hn.loopDuration=t},get reversed(){return hn.reversed},set reversed(t){hn.reversed=t,vn.mesh.options.reversed=t,vn.mesh.setChunks()},get easingFunction(){return hn.easingFunction},set easingFunction(t){hn.easingFunction=t,hn.easing.f=t,vn.mesh.setChunks()},get easingCategory(){return hn.easingCategory},set easingCategory(t){hn.easingCategory=t,hn.easing.category=t,vn.mesh.setChunks()},get grid(){return hn.grid},set grid(t){hn.grid=t,m.grid.visible=t}};const Fn={type:"change"},Sn={type:"start"},wn={type:"end"};class Pn extends i.EventDispatcher{constructor(t,e){super(),void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new i.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:i.MOUSE.ROTATE,MIDDLE:i.MOUSE.DOLLY,RIGHT:i.MOUSE.PAN},this.touches={ONE:i.TOUCH.ROTATE,TWO:i.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return s.phi},this.getAzimuthalAngle=function(){return s.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",B),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Fn),n.update(),o=r.NONE},this.update=function(){const e=new i.Vector3,h=(new i.Quaternion).setFromUnitVectors(t.up,new i.Vector3(0,1,0)),f=h.clone().invert(),p=new i.Vector3,m=new i.Quaternion,g=2*Math.PI;return function(){const t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(h),s.setFromVector3(e),n.autoRotate&&o===r.NONE&&T(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(s.theta+=u.theta*n.dampingFactor,s.phi+=u.phi*n.dampingFactor):(s.theta+=u.theta,s.phi+=u.phi);let i=n.minAzimuthAngle,v=n.maxAzimuthAngle;return isFinite(i)&&isFinite(v)&&(i<-Math.PI?i+=g:i>Math.PI&&(i-=g),v<-Math.PI?v+=g:v>Math.PI&&(v-=g),s.theta=i<=v?Math.max(i,Math.min(v,s.theta)):s.theta>(i+v)/2?Math.max(i,s.theta):Math.min(v,s.theta)),s.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,s.phi)),s.makeSafe(),s.radius*=l,s.radius=Math.max(n.minDistance,Math.min(n.maxDistance,s.radius)),!0===n.enableDamping?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),e.setFromSpherical(s),e.applyQuaternion(f),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),d.set(0,0,0)),l=1,!!(c||p.distanceToSquared(n.object.position)>a||8*(1-m.dot(n.object.quaternion))>a)&&(n.dispatchEvent(Fn),p.copy(n.object.position),m.copy(n.object.quaternion),c=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",H),n.domElement.removeEventListener("pointerdown",z),n.domElement.removeEventListener("pointercancel",k),n.domElement.removeEventListener("wheel",Q),n.domElement.removeEventListener("pointermove",Y),n.domElement.removeEventListener("pointerup",J),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",B)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=r.NONE;const a=1e-6,s=new i.Spherical,u=new i.Spherical;let l=1;const d=new i.Vector3;let c=!1;const h=new i.Vector2,f=new i.Vector2,p=new i.Vector2,m=new i.Vector2,g=new i.Vector2,v=new i.Vector2,x=new i.Vector2,y=new i.Vector2,A=new i.Vector2,b=[],_={};function N(){return Math.pow(.95,n.zoomSpeed)}function T(t){u.theta-=t}function F(t){u.phi-=t}const S=function(){const t=new i.Vector3;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),d.add(t)}}(),w=function(){const t=new i.Vector3;return function(e,i){!0===n.screenSpacePanning?t.setFromMatrixColumn(i,1):(t.setFromMatrixColumn(i,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),d.add(t)}}(),P=function(){const t=new i.Vector3;return function(e,i){const r=n.domElement;if(n.object.isPerspectiveCamera){const o=n.object.position;t.copy(o).sub(n.target);let a=t.length();a*=Math.tan(n.object.fov/2*Math.PI/180),S(2*e*a/r.clientHeight,n.object.matrix),w(2*i*a/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(S(e*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),w(i*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function L(t){n.object.isPerspectiveCamera?l/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function O(t){n.object.isPerspectiveCamera?l*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function E(t){h.set(t.clientX,t.clientY)}function I(t){m.set(t.clientX,t.clientY)}function R(){if(1===b.length)h.set(b[0].pageX,b[0].pageY);else{const t=.5*(b[0].pageX+b[1].pageX),e=.5*(b[0].pageY+b[1].pageY);h.set(t,e)}}function C(){if(1===b.length)m.set(b[0].pageX,b[0].pageY);else{const t=.5*(b[0].pageX+b[1].pageX),e=.5*(b[0].pageY+b[1].pageY);m.set(t,e)}}function U(){const t=b[0].pageX-b[1].pageX,e=b[0].pageY-b[1].pageY,n=Math.sqrt(t*t+e*e);x.set(0,n)}function M(t){if(1==b.length)f.set(t.pageX,t.pageY);else{const e=j(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);f.set(n,i)}p.subVectors(f,h).multiplyScalar(n.rotateSpeed);const e=n.domElement;T(2*Math.PI*p.x/e.clientHeight),F(2*Math.PI*p.y/e.clientHeight),h.copy(f)}function D(t){if(1===b.length)g.set(t.pageX,t.pageY);else{const e=j(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);g.set(n,i)}v.subVectors(g,m).multiplyScalar(n.panSpeed),P(v.x,v.y),m.copy(g)}function X(t){const e=j(t),i=t.pageX-e.x,r=t.pageY-e.y,o=Math.sqrt(i*i+r*r);y.set(0,o),A.set(0,Math.pow(y.y/x.y,n.zoomSpeed)),L(A.y),x.copy(y)}function z(t){!1!==n.enabled&&(0===b.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",Y),n.domElement.addEventListener("pointerup",J)),function(t){b.push(t)}(t),"touch"===t.pointerType?function(t){switch(G(t),b.length){case 1:switch(n.touches.ONE){case i.TOUCH.ROTATE:if(!1===n.enableRotate)return;R(),o=r.TOUCH_ROTATE;break;case i.TOUCH.PAN:if(!1===n.enablePan)return;C(),o=r.TOUCH_PAN;break;default:o=r.NONE}break;case 2:switch(n.touches.TWO){case i.TOUCH.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&U(),n.enablePan&&C(),o=r.TOUCH_DOLLY_PAN;break;case i.TOUCH.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&U(),n.enableRotate&&R(),o=r.TOUCH_DOLLY_ROTATE;break;default:o=r.NONE}break;default:o=r.NONE}o!==r.NONE&&n.dispatchEvent(Sn)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case i.MOUSE.DOLLY:if(!1===n.enableZoom)return;!function(t){x.set(t.clientX,t.clientY)}(t),o=r.DOLLY;break;case i.MOUSE.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;I(t),o=r.PAN}else{if(!1===n.enableRotate)return;E(t),o=r.ROTATE}break;case i.MOUSE.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;E(t),o=r.ROTATE}else{if(!1===n.enablePan)return;I(t),o=r.PAN}break;default:o=r.NONE}o!==r.NONE&&n.dispatchEvent(Sn)}(t))}function Y(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(G(t),o){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;M(t),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;D(t),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&X(t),n.enablePan&&D(t)}(t),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&X(t),n.enableRotate&&M(t)}(t),n.update();break;default:o=r.NONE}}(t):function(t){if(!1===n.enabled)return;switch(o){case r.ROTATE:if(!1===n.enableRotate)return;!function(t){f.set(t.clientX,t.clientY),p.subVectors(f,h).multiplyScalar(n.rotateSpeed);const e=n.domElement;T(2*Math.PI*p.x/e.clientHeight),F(2*Math.PI*p.y/e.clientHeight),h.copy(f),n.update()}(t);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY),A.subVectors(y,x),A.y>0?L(N()):A.y<0&&O(N()),x.copy(y),n.update()}(t);break;case r.PAN:if(!1===n.enablePan)return;!function(t){g.set(t.clientX,t.clientY),v.subVectors(g,m).multiplyScalar(n.panSpeed),P(v.x,v.y),m.copy(g),n.update()}(t)}}(t))}function J(t){!1!==n.enabled&&(t.pointerType,n.dispatchEvent(wn),o=r.NONE,V(t),0===b.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",Y),n.domElement.removeEventListener("pointerup",J)))}function k(t){V(t)}function Q(t){!1===n.enabled||!1===n.enableZoom||o!==r.NONE&&o!==r.ROTATE||(t.preventDefault(),n.dispatchEvent(Sn),function(t){t.deltaY<0?O(N()):t.deltaY>0&&L(N()),n.update()}(t),n.dispatchEvent(wn))}function B(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:P(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:P(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:P(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:P(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function H(t){!1!==n.enabled&&t.preventDefault()}function V(t){delete _[t.pointerId];for(let e=0;e<b.length;e++)if(b[e].pointerId==t.pointerId)return void b.splice(e,1)}function G(t){let e=_[t.pointerId];void 0===e&&(e=new i.Vector2,_[t.pointerId]=e),e.set(t.pageX,t.pageY)}function j(t){const e=t.pointerId===b[0].pointerId?b[1]:b[0];return _[e.pointerId]}n.domElement.addEventListener("contextmenu",H),n.domElement.addEventListener("pointerdown",z),n.domElement.addEventListener("pointercancel",k),n.domElement.addEventListener("wheel",Q,{passive:!1}),this.update()}}var Ln;function On(){var t=window,e=t.innerWidth,n=t.innerHeight,i=t.devicePixelRatio,r=e,o=n;[m,pe].forEach((function(t){return t.resize(r,o,i)}))}function En(t){[pe,vn].forEach((function(e){return e.update(t)}))}Ln={init:function(){var t=new Pn(m.camera,pe.canvas);t.screenSpacePanning=!1,t.minDistance=4,t.maxDistance=20,t.maxPolarAngle=Math.PI/2,Ln.orbit=t,document.getElementById("random").addEventListener("click",(function(){vn.random()}))}},function(){pe.init(),vn.init(),xn.init(),Ln.init(),window.addEventListener("resize",On),On();var t=new n(En,0);vn.ticker=t,t.start()}()})();